# 8.3 API 게이트웨이 구현

<b> API 게이트웨이를 구현하는 방법 </b>

-   기성(off-the-shelf) API 게이트웨이 제품/서비스를 활용: 개발 노력은 거의 안들지만 유연성이 제일 떨어짐. 기성 API 게이트웨이 제품은 대체로 API 조합을 지원하지 않음.

-   API 게이트웨이 프레임워크 또는 웹 프레임워크를 기반으로 API 게이트웨이를 직접 개발: 가장 유연한 접근 방식이지만, 적잖은 개발 노력이 투입

<br />

## 8.3.1 기성 API 게이트웨이 제품/서비스 활용

### AWS API 게이트웨이

-   하나 이상의 HTTP 메서드를 지원하는 REST 리소스 세트
-   API 게이트웨이 요건을 대부분 충족
-   처음에 구성만 잘 해두면 확장 등 나머지 일은 모두 AWS가 알아서 처리하므로 직접 설치/운영을 신경쓸 일이 없음.
-   API 조합을 지원하지 않기 때문에 직접 백엔드 서비스에 조합 로직을 구현해야 함.
-   주로 JSON 위주의 HTTP(S)만, 서버 쪽 디스커버리 패턴만 지원

### AWS 애플리케이션 부하 분산기

AWS ALB(Application Load Balancer): HTTP, HTTPS, 웹 소켓, HTTP/2용 부하 분산기

-   API 게이트웨이로서의 기본적인 요건 어느정도 축족
-   기능이 제한적이고 HTTP 메서드 기반의 라우팅, API 조합, 인증 같은 로직이 없음.

### 다른 API 게이트웨이 제품

콩(Kong) 이나 트래픽(Traefik) 등 직접 설치/운영할 수 있는 오픈 소스 제품도 있음.

-   강력한 라우팅, 엣지 기능이 탑재
-   API 조합은 여전히 지원하지 않음.

<br />

## 8.3.2 API 게이트웨이 자체 개발

### 검토해야 할 이슈

-   코딩 복잡도를 최소화할 수 있는 라우팅 규칙 정의 메커니즘을 구현
-   HTTP 헤더 처리 등 HTTP 프록시 로직을 정확히 구현

### 넷플릭스 주울

라우팅, 사용량 제한, 인증 같은 엣지 기능이 탑재된 프레임워크

-   HTTP 요청을 변환하는 필터 체인을 적절히 조합해서 요청을 처리하고, 백엔드 서비스를 호출 후 클라이언트에 반환하기 직전에 응답을 가공

-   라우팅과 엣지 기능을 처리하며, API 조합이 구현된 스프링 MVC 컨트롤러를 정의하면 확장 가능
    -   `[단점]` 경로 기반의 라우팅만 지원됨.

### 스프링 클라우드 게이트웨이

스프링5, 스프링 부트2, 스프링 웹플럭스 등의 프레임워크를 토대로 한 API 게이트웨이 프로젝트

#### 범용적 수단

-   요청을 백엔드 서비스로 보냅니다.
-   API를 조합하는 요청 핸들러 역할을 합니다.
-   인증 등의 엣지 기능을 처리

#### API 게이트웨이 핵심 요소

-   `ApiGatewayMain 패키지`: API 게이트웨이의 메인 프로그램
-   `하나 이상의 API 패키지`: API 끝점이 구현된 API 패키지.
-   `프록시 패키지`: 서비스를 호출하기 위해 API 패키지가 사용하는 프록시 클래스로 구성

`코드: [p.349 ~ p.355 참고]`

<br />

## 8.3.3 API 게이트웨이 구현: GraphQL

-   API 게이트웨이에 별의별 클라이언트를 지원하는 REST AP를 구현하는 것은 시간낭비.

-   GraphQL 처럼 데이터를 효율적으로 가져오도록 설계된 그래프 기반의 API 프레임워크를 사용
    -   `그래프 기반 API 프레임워크`: 그래프 기반의 스키마로 서버 API를 구성하는 것이 핵심

#### 그래프 기반의 API 기술의 장점

1. 클라이언트가 반환 데이터를 제어할 수 있음.
2. 개발 수고를 엄청나게 덜 수 있음.
    - 서버 쪽 코드를 API 조합과 투사를 지원하도록 설계된 쿼리 실행 프레임워크로 작성
    - 마치 클라이언트가 저장 프로시저(stored procedure)를 통해 데이터를 조회하도록 강제하는 대신 클라이언트가 직접 하부 DB를 대상으로 쿼리하게끔 만드는 것.

#### GraphQL 기반 API 게이트웨이 설계 핵심 요소

-   `GraphQL 스키마`: 서버 쪽 데이터 모델 및 이 모델이 지원하는 쿼리를 정의
-   `리졸버 함수`: 스키마 엘리먼트를 다양한 백엔드 서비스에 매핑
-   `프록시 클래스`: FTGO 애플리케이션 서비스를 호출

### GraphQL 스키마 정의

-   GraphQL API는 스키마 중심적.
    -   서버 쪽 데이터 모델과 작업(예: 클라이언트가 수행 가능한 쿼리)의 구조를 정의한 타입들로 구성
-   타입: 데이터 모델을 정의할 때 주로 많이 쓰는 `객체형(object type)`과 자바 이늄과 비슷한 `이늄(enum)`
-   GraphQL에서는 스키마에서 지원되는 쿼리를 필드로 정의.
-   GraphQL은 클라이언트가 반환 데이터를 좌지우지할 수 있게 강력한 제어권을 부여.

### GraphQL 쿼리 실행

-   클라이언트가 반환 데이터를 쿼리 언어로 자유롭게 제어할 수 있음.
-   클라이언트는 쿼리 문서(query document)가 담긴 요청을 서버에 전송하여 쿼리를 실행.

### 스키마를 데이터에 연결

-   GraphQL 서버는 처음에 최상위 쿼리로 데이터를 가져와 결과 객체(들)의 필드를 재귀 조회하는 리졸버 함수를 호출하여 API를 조합.

#### 리졸버 함수의 매개변수

-   `객체`: 최상위 쿼리 필드의 경우, 루트 객체 object는 보통 리졸버 함수가 무시.
    그 외의 경우에는 리졸버가 부모 객체에 반환한 값이 object

-   `쿼리 인수`: 쿼리 문서에 명시된 값
-   `컨텍스트`: 모든 리졸버가 접근 가능한 전역 쿼리 실행 상태. 사용자 정보, 디펜던시를 리졸버에 전달하는 용도로 사용

리졸버 함수는 단일 서비스를 호출하거나 API를 조합해서 여러 서비스의 데이터를 가져올 수 있음.

### 배칭/캐싱으로 로딩 최적화

-   GraphQL은 쿼리 실행 시 엄청나게 많은 리졸버를 실행하게 될 가능성이 항상 있음
-   각각의 리졸버는 독립적으로 실행되므로 서비스 왕복 횟수가 너무 많아지면 성능이 뚝 떨어질 위험성 존재
-   GraphQL 엔진이 서비스를 병렬 호출하더라도 성능이 저하될 우려가 있음.

<b>성능을 최적화 하기 위해 서버 쪽에서 배치/캐싱을 조합하여 사용</b>

-   `배칭`: 서비스를 N번 호출할 것을 N개 객체를 일괄 조회하는 호출 한번으로 전환
-   `캐싱`: 불필요한 중복 호출을 방지하기 위해 동일한 객체를 가져왔던 이전 결과를 재사용
-   Node.js 기반의 GraphQL 서버에서 배칭/캐싱을 구현하려면 `데이터로더(DataLoader)` 모듈을 사용

### 아폴로 GraphQL 서버와 익스프레스를 연계

-   아폴로 GraphQL 서버는 Node.js 진영에서 유명한 익스프레스(Express) 등 다양한 웹 프레임워크와의 연계를 지원

### GraphQL 클라이언트 작성

-   GraphQL 서버는 HTTP 기반의 API를 제공하므로 클라이언트 애플리케이션은 적당한 HTTP 라이브러리를 이용하여 요청.
-   요청 포맷을 적절히 잘 맞추어 주면서 클라이언트 쪽 캐싱 등의 기능까지 제공하는 GraphQL 클라이언트 라이브러리를 사용한 것이 더 쉬움.
