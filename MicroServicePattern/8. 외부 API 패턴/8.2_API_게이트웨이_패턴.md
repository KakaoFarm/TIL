# 8.2 API 게이트웨이 패턴

마이크로서비스 애플리케이션에 외부 API 클라이언트의 진입점에 해당하는 서비스를 구현

<br />

## 8.2.1 API 게이트웨이 패턴 개요

-   퍼사드처럼 API 게이트웨이도 내부 애플리케이션 아키텍처를 캡슐화하고 자신의 클라이언트에는 API를 제공
-   인증, 모니터링, 사용량 제한
-   요청 라우팅
-   API 조합
-   프로토콜 변환(클라이언트에 친화적인 프로토콜(예: HTTP, 웹 소켓)과 비친화적인 프로토콜 간 변환도 함.)

### 요청 라우팅

-   요청이 들어오면 API 게이트웨이는 라우팅 맵(routing map)을 찾아보고 어느 서비스로 요청을 보낼지 결정
-   nginx 같은 웹 서버의 리버스 프록시와 같음.

### API 조합

-   모바일 앱이 API 게이트웨이에 요청을 한 번 하면 API 게이트웨이는 여러 서비스에서 주문 내역 데이터를 조회

-   API 게이트웨이는 모바일 클라이언트가 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 API 제공

### 프로토콜 변환

-   애플리케이션 내부에서 REST와 gRPC를 혼용할 경우에도 외부 클라이언트에는 REST API를 제공할 수 있음.

### API 게이트웨이는 클라이언트마다 적합한 API를 제공한다.

-   모바일 클라이언트에는 모바일 요건에 맞게 설계된 API와 서드파티 개발자용 퍼블릭 API를 구현

### 엣지 기능 구현

-   인증(authentication): 요청한 클라이언트의 신원을 확인
-   인가(authorization): 특정 작업을 수행하도록 허가받은 클라이언트인지 확인
-   사용량 제한(rate limiting): 특정(또는 전체) 클라이언트의 초당 요청 개수를 제한
-   캐싱(caching): 서비스 요청 횟수를 줄이고자 응답을 캐시
-   지표 수집(metrics collection): 과금 분석용 API 사용 지표 수집
-   요청 로깅: 요청을 기록

#### 엣지 기능이 구현된 곳

-   백엔드 서비스
-   외부 클라이언트가 직접 맞닿은 API 게이트웨이의 상류(upstream)
-   전용 엣지 서비스
    -   `장점`: 관심사가 분리, API 라우팅/조합에 집중하고 중요한 엣지 기능을 중앙화 할 수 있음.
    -   `단점`: 홉(hop) 카운트가 늘어나기 때문에 네트워크 지연이 증가하고 애플리케이션 복잡도 역시 증가

### API 게이트웨이 아키텍처

-   그림[8-5] 참고
-   API 계층에는 독립적인 하나 이상의 API 모듈이 있고, 각 API 모듈에는 특정 클라이언트용 API가 구현.
-   공통 계층에는 엣지 기능 등의 공통 기능이 구현.

#### API 게이트웨이 API 모듈

-   모바일 API: FTGO 모바일 클라이언트용 API 구현
-   브라우저 API: 브라우저에서 실행되는 자바스크립트 애플리케이션용 API 구현
-   퍼블릭 API: 서드파티 개발자용 API 구현

<b> API 작업 구현 </b>

1. 서비스 API 하나에 직접 매핑되는 API 작업은 해당하는 각각의 서비스 API로 요청을 보낸다.
2. API를 조합하는 복잡한 API 작업은 사용자 정의 코드로 구현

### API 게이트웨이 소유권 모델

-   API 게이트웨이를 전담할 팀을 따로 신설
-   넷플릭스에서 권장하는 것처럼 API가 표출된 모듈은 해당 클라이언트 팀(모바일, 웹, 퍼블릭 API 팀)이 소유하는 구조.
-   소유권 모델에 따르면 API를 개발한 팀별로 권한 부여
-   API 게이트웨이 배포 파이프라인을 완전히 자동화 해야함.

### 프런트엔드 패턴을 위한 백엔드

책임이 불분명해질 수 있기 때문에 각 클라이언트마다 API 게이트웨이를 따로 두는 BFF(Backends For Frontends) 패턴을 적용하는 것.

`BFF 패턴`: 클라이언트마다 API 게이트웨이를 따로 두고 클라이언트 팀은 자체 API 게이트웨이를, API 게이트웨이 팀은 공통 계층을 소유

-   API 모듈이 서로 격리되어 신뢰성이 향상.
-   자체 프로세스로 작동되므로 관측성이 좋아지고, 각 API를 독립적으로 확장할 수 있음.
-   API 게이트웨이를 더 작고 단순한 애플리케이션으로 만들 수 있어서 시동 시간 단축

<br />

## 8.2.2 API 게이트웨이의 장단점

### API 게이트웨이의 장점

-   애플리케이션의 내부 구조를 캡슐화
-   API 게이트웨이는 클라이언트마다 최적의 API를 제공하므로 클라이언트-애플리케이션 간 왕복 횟수가 줄고, 클라이언트 코드 역시 단순화

### API 게이트웨이의 단점

-   개발, 배포, 관리를 해야 하는 고가용 컴포넌트가 하나 더 늘어나는 부담이 생김
-   개발 병목 지점이 될 우려

<br />

## 8.2.3 API 게이트웨이 사례: 넷플릭스

-   기기별 API가 따로 구현된 API 게이트웨이를 사용하며, API 구현 코드는 클라이언트 기기 팀이 소유/개발

-   각 API 모듈은 자체 도커 컨테이너(Docker container)로 실행되지만 스크립트가 서비스를 직접 호출하는 것이 아니라, 넷플릭스 팔코(Netflix Falcor)를 이용하여 서비스 API를 표출한 부차(second) `'API 게이트웨이'`를 호출

<br />

## 8.2.4 API 게이트웨이 설계 이슈

-   성능과 확장성
-   리액티브 프로그래밍 추상체를 이용하여 관리 가능한 코드 작성
-   부분 실패 처리
-   애플리케이션 아키텍처에서 선량한 시민(good citizen)되기

### 성능과 확장성

API 게이트웨이에 동기 I/O를 사용할 것인가, 비동기 I/O를 사용할 것인가 하는 문제는 성능 및 확장성에 가장 큰 영향을 미치는 설계 결정

-   `동기 I/O 모델`: 각 네트워크 접속마다 스레드를 하나식 배정
-   `비동기(논블로킹) I/O 모델`: 단일 이벤트 루프 스레드(single event loop thread) 가 I/O 요청을 각 이벤트 핸들러로 디스패치

### 리액티브 프로그래밍 추상체

-   API 끝점 핸들러 메서드가 디펜던시에 의해 결정된 순서대로 서비스를 호출 -> 응답시간 문제

-   기존 비동기 콜백 방식으로 API 조합 코드를 작성하면 콜백지옥(callback hell)에 빠지게 됨.

-   API 조합 코드는 리액티브하게 선언형 스타일로 작성.
-   대표적인 JVM용 리액티브 추상체

    -   자바 8 CompletableFutures
    -   리액터 프로젝트(Project Reactor) Mono
    -   RxJava(Reactive Extensions for Java) 의 옵저버블(observable)
    -   스칼라 Fture

-   리액티브 추상체를 잘 활용하면 이해하기 쉽고 단순한 동시성 코드를 작성할 수 있음.

### 부분 실패 처리

-   특정 인스턴스가 실패하면 부하 분산기가 알아서 요청을 다른 인스턴스에 라우팅
-   실패한 요청, 그리고 지연 시간이 너무 긴 요청도 적절히 잘 처리해야 함.

### 아키텍처의 선량한 시민 되기

-   서비스 디스커버리 패턴을 이용하면 API 게이트웨이 같은 서비스 클라이언트가 자신이 호출할 서비스 인스턴스의 네트워크 위치를 파악할 수 있음.
-   관측성 패턴을 활용하면 개발자가 애플리케이션 동작 상태를 모니터링하고 문제를 진단하는데 도움이 됨.
