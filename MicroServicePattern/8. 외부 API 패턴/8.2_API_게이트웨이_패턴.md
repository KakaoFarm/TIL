# 8.2 API 게이트웨이 패턴

마이크로서비스 애플리케이션에 외부 API 클라이언트의 진입점에 해당하는 서비스를 구현

<br />

## 8.2.1 API 게이트웨이 패턴 개요

-   퍼사드처럼 API 게이트웨이도 내부 애플리케이션 아키텍처를 캡슐화하고 자신의 클라이언트에는 API를 제공
-   인증, 모니터링, 사용량 제한
-   요청 라우팅
-   API 조합
-   프로토콜 변환(클라이언트에 친화적인 프로토콜(예: HTTP, 웹 소켓)과 비친화적인 프로토콜 간 변환도 함.)

### 요청 라우팅

-   요청이 들어오면 API 게이트웨이는 라우팅 맵(routing map)을 찾아보고 어느 서비스로 요청을 보낼지 결정
-   nginx 같은 웹 서버의 리버스 프록시와 같음.

### API 조합

-   모바일 앱이 API 게이트웨이에 요청을 한 번 하면 API 게이트웨이는 여러 서비스에서 주문 내역 데이터를 조회

-   API 게이트웨이는 모바일 클라이언트가 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 API 제공

### 프로토콜 변환

-   애플리케이션 내부에서 REST와 gRPC를 혼용할 경우에도 외부 클라이언트에는 REST API를 제공할 수 있음.

### API 게이트웨이는 클라이언트마다 적합한 API를 제공한다.

-   모바일 클라이언트에는 모바일 요건에 맞게 설계된 API와 서드파티 개발자용 퍼블릭 API를 구현

### 엣지 기능 구현

-   인증(authentication): 요청한 클라이언트의 신원을 확인
-   인가(authorization): 특정 작업을 수행하도록 허가받은 클라이언트인지 확인
-   사용량 제한(rate limiting): 특정(또는 전체) 클라이언트의 초당 요청 개수를 제한
-   캐싱(caching): 서비스 요청 횟수를 줄이고자 응답을 캐시
-   지표 수집(metrics collection): 과금 분석용 API 사용 지표 수집
-   요청 로깅: 요청을 기록

#### 엣지 기능이 구현된 곳

-   백엔드 서비스
-   외부 클라이언트가 직접 맞닿은 API 게이트웨이의 상류(upstream)
-   전용 엣지 서비스
    -   `장점`: 관심사가 분리, API 라우팅/조합에 집중하고 중요한 엣지 기능을 중앙화 할 수 있음.
    -   `단점`: 홉(hop) 카운트가 늘어나기 때문에 네트워크 지연이 증가하고 애플리케이션 복잡도 역시 증가

### API 게이트웨이 아키텍처

-   그림[8-5] 참고
-   API 계층에는 독립적인 하나 이상의 API 모듈이 있고, 각 API 모듈에는 특정 클라이언트용 API가 구현.
-   공통 계층에는 엣지 기능 등의 공통 기능이 구현.

#### API 게이트웨이 API 모듈

-   모바일 API: FTGO 모바일 클라이언트용 API 구현
-   브라우저 API: 브라우저에서 실행되는 자바스크립트 애플리케이션용 API 구현
-   퍼블릭 API: 서드파티 개발자용 API 구현

<b> API 작업 구현 </b>

1. 서비스 API 하나에 직접 매핑되는 API 작업은 해당하는 각각의 서비스 API로 요청을 보낸다.
2. API를 조합하는 복잡한 API 작업은 사용자 정의 코드로 구현

### API 게이트웨이 소유권 모델

-   API 게이트웨이를 전담할 팀을 따로 신설
-   넷플릭스에서 권장하는 것처럼 API가 표출된 모듈은 해당 클라이언트 팀(모바일, 웹, 퍼블릭 API 팀)이 소유하는 구조.
-   소유권 모델에 따르면 API를 개발한 팀별로 권한 부여
-   API 게이트웨이 배포 파이프라인을 완전히 자동화 해야함.

### 프런트엔드 패턴을 위한 백엔드

책임이 불분명해질 수 있기 때문에 각 클라이언트마다 API 게이트웨이를 따로 두는 BFF(Backends For Frontends) 패턴을 적용하는 것.

`BFF 패턴`: 클라이언트마다 API 게이트웨이를 따로 두고 클라이언트 팀은 자체 API 게이트웨이를, API 게이트웨이 팀은 공통 계층을 소유

-   API 모듈이 서로 격리되어 신뢰성이 향상.
-   자체 프로세스로 작동되므로 관측성이 좋아지고, 각 API를 독립적으로 확장할 수 있음.
-   API 게이트웨이를 더 작고 단순한 애플리케이션으로 만들 수 있어서 시동 시간 단축
