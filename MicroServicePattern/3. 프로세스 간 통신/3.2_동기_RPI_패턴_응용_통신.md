# 동기 RPI 패턴 응용 통신

RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC.

<img src="https://thebook.io/img/007035/113.jpg" width="100%">

## 3.2.1 동기 RPI 패턴: REST

-   REST는 (거의 항상) HTTP로 소통하는 IPC.

```
REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트의 독립적 배포, 상호 작용 지연을 줄이기 위해
중간 컴포넌트, 보안강화, 레거시 시스템의 캡슐화에 역점을 둔 아키텍처 제약 조건 세트를 제공한다.
- 로이 필딩
```

### REST 성숙도 모델

-   레벨 0: 클라이언트는 서비스별로 유일한 URL 끝점에 HTTP POST 요청을 하여 서비스를 호출
-   레벨 1: 서비스는 리소스 개념을 지원
-   레벨 2: 서비스는 HTTP 동사를 이용해서 액션을 수행하고, 요청 쿼리 매개변수 및 본문, 필요 시 매개변수를 지정
-   레벨 3: 서비스를 HATEOAS 원칙에 기반하여 설계, 리소스에 대한 액션의 링크도 함께 태워 보내자!

### REST API

-   REST는 원래 IDL이 없다.
-   IDL의 필요성이 있어 스웨거라는 오픈 소스 프로젝트를 발전시켜 오픈 API 명세가 REST IDL로 널리 보급됨.
-   스웨거는 REST API를 개발/문서화하는 도구 세트.

### 요청 한 번으로 많은 리소스를 가져오기 어렵다.

-   문제: REST 리소스는 비즈니스 객체 중심이기 때문에 시나리오가 복잡해지면 왕복 횟수가 증가하고 지연시간이 급증
-   해결: 클라이언트가 리소스를 획득할 때 연관된 리소스도 함께 조회하도록 API가 허락
    -   GraphQL
    -   넷플릭스 팔코

### 작업을 HTTP 동사에 매핑하기 어렵다.

-   비즈니스 객체에 수행할 작업을 HTTP 동사에 어떻게 매핑?
-   `PUT` : 업데이트 하는 경로는 다양, 멱등성이 보장 되지 않는 업데이트 존재
-   해결: 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의
    -   `POST /orders/{orderId}/cancel`
    -   `POST /orders/{orderId}/revise`

### REST의 장단점

#### 장점

-   단순하고 익숙
-   CLI 도구를 사용해서 HTTP API를 간편하게 테스트
-   요청/응답 스타일의 통신을 직접 지원
-   방화벽 친화적
-   중간 브로커가 필요하지 않아 시스템 아키텍처가 단순

#### 단순

-   요청/응답 스타일의 통신만 지원
-   가용성이 떨어짐. 클라이언트/서비스가 다 실행중이어야 함.
-   서비스 인스턴스들의 URL을 클라이언트가 알고 있어야 함.
-   요청 한 번으로 여러 리소스를 가져오기 어렵다.
-   다중 업데이트 작업을 HTTP 동사에 매핑하기 어려움

<br />

## 개념정리

`멱등성`: 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질

## 질문사항

1. REST API를 구현할 때 HATEOAS와 self-descriptive message를 지키지 않았을 때 REST API라고 부를 수 있는지에 대한 궁금함이 듭니다! REST 성숙도 모델에서 레벨3에 HATEOAS가 명시되어 있어 질문드립니다!

    - 또한 추가적으로, 이런 HATEOAS가 없을 시 도입하려는 움직임이나 시도, 그리고 실제 HATEOAS를 적용한 사례가 궁금합니다!

2. `PUT 사용 시 필수 요건인 멱등성이 보장되지 않는 업데이트도 있습니다.` 라고 명시 되어 있는데 이러한 경우는 언제인가요?
