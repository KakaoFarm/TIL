# 동기 RPI 패턴 응용 통신

RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC.

<img src="https://thebook.io/img/007035/113.jpg" width="100%">

## 3.2.1 동기 RPI 패턴: REST

-   REST는 (거의 항상) HTTP로 소통하는 IPC.

```
REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트의 독립적 배포, 상호 작용 지연을 줄이기 위해
중간 컴포넌트, 보안강화, 레거시 시스템의 캡슐화에 역점을 둔 아키텍처 제약 조건 세트를 제공한다.
- 로이 필딩
```

### REST 성숙도 모델

-   레벨 0: 클라이언트는 서비스별로 유일한 URL 끝점에 HTTP POST 요청을 하여 서비스를 호출
-   레벨 1: 서비스는 리소스 개념을 지원
-   레벨 2: 서비스는 HTTP 동사를 이용해서 액션을 수행하고, 요청 쿼리 매개변수 및 본문, 필요 시 매개변수를 지정
-   레벨 3: 서비스를 HATEOAS 원칙에 기반하여 설계, 리소스에 대한 액션의 링크도 함께 태워 보내자!

### REST API

-   REST는 원래 IDL이 없다.
-   IDL의 필요성이 있어 스웨거라는 오픈 소스 프로젝트를 발전시켜 오픈 API 명세가 REST IDL로 널리 보급됨.
-   스웨거는 REST API를 개발/문서화하는 도구 세트.

### 요청 한 번으로 많은 리소스를 가져오기 어렵다.

-   문제: REST 리소스는 비즈니스 객체 중심이기 때문에 시나리오가 복잡해지면 왕복 횟수가 증가하고 지연시간이 급증
-   해결: 클라이언트가 리소스를 획득할 때 연관된 리소스도 함께 조회하도록 API가 허락
    -   GraphQL
    -   넷플릭스 팔코

### 작업을 HTTP 동사에 매핑하기 어렵다.

-   비즈니스 객체에 수행할 작업을 HTTP 동사에 어떻게 매핑?
-   `PUT` : 업데이트 하는 경로는 다양, 멱등성이 보장 되지 않는 업데이트 존재
-   해결: 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의
    -   `POST /orders/{orderId}/cancel`
    -   `POST /orders/{orderId}/revise`

### REST의 장단점

#### 장점

-   단순하고 익숙
-   CLI 도구를 사용해서 HTTP API를 간편하게 테스트
-   요청/응답 스타일의 통신을 직접 지원
-   방화벽 친화적
-   중간 브로커가 필요하지 않아 시스템 아키텍처가 단순

#### 단순

-   요청/응답 스타일의 통신만 지원
-   가용성이 떨어짐. 클라이언트/서비스가 다 실행중이어야 함.
-   서비스 인스턴스들의 URL을 클라이언트가 알고 있어야 함.
-   요청 한 번으로 여러 리소스를 가져오기 어렵다.
-   다중 업데이트 작업을 HTTP 동사에 매핑하기 어려움

<br />

## 3.2.2 동기 RPI 패턴: gRPC

gRPC: 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크.

-   이진 메시지 기반의 프로토콜 -> API 우선 방식 설계
-   프로토콜 버퍼 기반의 IDL
-   gRPC API는 하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성
-   단순 요청/응답 RPC는 물론 스트리밍 RPC도 지원
-   [레퍼런스](https://jaime-note.tistory.com/82)

### gRPC 장점

-   다양한 업데이트 작업이 포함된 API를 설계하기 쉬움
-   큰 메시지를 교환할 때 콤팩트하고 효율적인 IPC
-   메시징 두 가지 통신 방식 모두 가능
-   다양한 언어로 작성된 클라이언트/서버 간 연동이 가능

### gRPC 단점

-   자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 더 많음
-   구형 방화벽은 HTTP/2를 지원하지 않음.

<br />

## 3.2.3 부분 실패 처리: 회로 차단기 패턴

회로 차단기 패턴: 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시.

### 부분 실패 시 솔루션

-   무응답 원격 서비스를 처리하기 위해 견고한 RPI 프록시를 설계
-   원격 서비스가 실패하면 어떻게 조치해야 할지 결정

### 견고한 RPI 프록시 설계

넷플릭스 기술 블로그 참고.

-   네트워크 타임아웃: 무한정 블로킹 대비 항상 타임아웃을 걸어둔다.
-   미처리 요청(outstanding request) 개수 제한: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수 설정
-   회로 차단기 패턴: 성공/실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면 그 이후 시도는 바로 실패 처리.

### 불능 서비스 복구

-   상황에 맞게 판단
-   여러 서비스를 호출해서 수신할 응답을 앱에 보내고, 이때 호출한 서비스가 각각 실패할 경우를 대비한 대응 방안이 있어야 함.

## 3.2.4 서비스 디스커버리

서비스 인스턴스마다 네트워크 위치가 동적 배정되고, 서비스 인스턴스는 자동 확장, 실패, 업그레이드 등 여러 이유로 달라지기 때문에 클라이언트 코드는 서비스 디스커버리를 사용.

### 서비스 디스커버리 개요

-   핵심: 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리
-   서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리 업데이트
-   서비스 호출시 서비스 디스커버리가 서비스 레지스트리에서 가용 서비스 인스턴스 목록을 가져오고 그 중 한 서비스로 요청 라우팅

### 애플리케이션 수준의 서비스 디스커버리 패턴 적용

-   애플리케이션 클라이언트/서비스가 서비스 레지스트리와 직접 통신

순서

1. 서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리에 등록
2. 서비스 클라이언트는 서비스 레지스트리부터 전체 서비스 인스턴스 목록을 가져옴.
3. 한 인스턴스로 요청을 라우팅

#### 패턴: 자가 등록

서비스 인스턴스는 서비스 레지스트리에 자기 자신을 등록한다.

#### 패턴: 클라이언트 쪽 디스커버리

서비스 클라이언트는 서비스 레지스트리에 있는 가용 서비스 인스턴스 목록을 조회하고 부하 분산한다.

### 플랫폼에 내장된 서비스 디스커버리 패턴 적용

도커나 쿠버네티스 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 메커니즘이 탑재.

-   `서드파티 등록 패턴`: 서비스가 자신을 서비스 레지스트리에 등록하는 것이 아니라, 배포 플랫폼의 일부인 `등록기` 라는 서드파티가 이 작업을 대행
-   `서버 쪽 디스커버리 패턴`: 클라이언트가 서비스 레지스트리를 질의하지 않고, 서비스 디스커버리를 담당한 라우터에 요청

해당 플랫폼으로 배포한 서비스 디스커버리만 지원하지만, 가능한 플랫폼에서 제공되는 서비스 디스커버리를 사용하는 것이 좋다!

<br />

## 개념정리

`멱등성`: 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질

## 질문사항

1. REST API를 구현할 때 HATEOAS와 self-descriptive message를 지키지 않았을 때 REST API라고 부를 수 있는지에 대한 궁금함이 듭니다! REST 성숙도 모델에서 레벨3에 HATEOAS가 명시되어 있어 질문드립니다!

    - 또한 추가적으로, 이런 HATEOAS가 없을 시 도입하려는 움직임이나 시도, 그리고 실제 HATEOAS를 적용한 사례가 궁금합니다!

2. `PUT 사용 시 필수 요건인 멱등성이 보장되지 않는 업데이트도 있습니다.` 라고 명시 되어 있는데 이러한 경우는 언제인가요?

3. REST 는 많이 듣고 사용되는 것을 들었지만(면접에서도 많이 나오는 질문이구요!) gRPC는 생소한데 이를 사용하는 곳이나 좀 더 상세한 예제가 있을까요? 완벽하게 이해가 잘 되지 않아서요! 특히 `자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 더 많다`는 것이 잘 이해가 되지 않습니다!
