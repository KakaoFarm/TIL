# 3.3 비동기 메시징 패턴 응용 통신

메시징: 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식.

-   서비스 간 중개 역할을 하는 메시지 브로커 사용
-   직접 서로 통신하는 브로커리스 아키텍처

클라이언트는 비동기 메시징을 통해 서비스를 호출

## 3.3.1 메시징 개요

-   메시지는 메시지 채널을 통해 교환한다.
-   애플리케이션 또는 서비스가 채널에 메시지를 쓰면 수신자(애플리케이션 또는 서비스)는 채널에서 메세지를 읽음.

### 메시지

헤더(header): 송신된 데이터에 관한 메타데이터에 해당하는 키/값들로 구성

-   송신자 또는 메시징 인프라에서 생성된 메시지 ID, 응답이 출력될 메시지 채널을 가리키는 반환 주소 포함

본문(body): 실제로 송신할 텍스트 또는 이진 포맷의 데이터

-   문서(document): 데이터만 포함된 제너릭한 메시지.
-   커맨드(command): RPC 요청과 동등한 메시지
-   이벤트(event): 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 대부분 도메인 객체의 상태 변화를 나타내는 도메인 이벤트

### 메시지 채널

메시지는 채널을 통해 교환.
<img src="https://thebook.io/img/007035/128.jpg" width="100%">

#### 채널의 종류

-   점대점(point-to-point) 채널: 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달.
-   발행-구독(publish-subscribe): 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달. (Ex. 이벤트 메시지)

## 3.3.2 메시징 상호 작용 스타일 구현

### 요청/응답 및 비동기 요청/응답

-   요청/응답 및 비동기 요청/응답 방식 모두 클라이언트가 요청을 보내면 서비스는 응답을 반환
-   클라이언트/서비스는 한 쌍의 메시지를 주고받는 비동기 요청/응답 스타일로 상호 작용

<img src="https://thebook.io/img/007035/129.jpg" width="100%">

-   클라이언트: MessageId 및 응답 채널이 헤더에 명시된 커맨드 메시지를 보낸다.
-   서버: MessageId와 같이 동일한 CorrelationId가 포함된 응답 메시지를 지정된 응답 채널에 사용

클라이언트는 CorrelationId를 이용하여 응답 메시지와 요청을 맞출 수 있다.

### 단방향 알림

서비스가 소유한 점대점 채널로 클라이언트가 메시지를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리하는 구조.

### 발행/구독

-   클라이언트는 여러 컨슈머가 읽는 발행/구독 채널에 메시지를 발행
-   서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행

### 발행/비동기 응답

1. 클라이언트는 응답 채널 헤더가 명시된 메시지를 발행/구독 채널에 발행
2. 컨슈머는 CorrelationId가 포함된 응답 메시지를 지정된 응답 채널에 씀.
3. 클라이언트는 CorrelationId로 응답을 취합하여 응답 메시지와 요청을 맞춤.

## 3.3.3 메시징 기반 서비스의 API 명세 작성

### 비동기 작업 문서화

-   요청/비동기 응답 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷, 서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성
-   단방향 알림 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성

### 발행 이벤트 문서화

-   API 명세는 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성

<br />

## 3.3.4 메시지 브로커

메시지 브로커: 서비스가 서로 통신할 수 있게 해주는 인프라 서비스
<img src="https://thebook.io/img/007035/132.jpg" width="100%">

### 브로커리스 메시징

브로커리스 아키텍처의 서비스는 메시지를 서로 직접 교환.

#### 장점

-   직접 전달되므로 네트워크 트래픽이 가볍고 지연 시간이 짧음.
-   메시지 브로커가 성능 병목점이나 SPOF(Single Point Of Failure, 단일 장애점)가 될 일이 없음.
-   메시지 브로커를 설정/관리할 필요 없어 운영 복잡도 낮음.

#### 단점

-   서비스 디스커버리 메커니즘 중 하나를 사용해야 함.
-   메시지 교환 시 송신자/수신자 모두 실행중이어야 함.
-   전달 보장 같은 메커니즘을 구현하기가 더 어려움.
    <br />

### 브로커 기반 메시징 개요

#### 장점

-   송신자가 컨슈머의 네트워크 위치를 몰라도 된다.
-   컨슈머가 메시지를 처리할 수 있을 때까지 메시지 브로커에 메시지를 버퍼링 할 수 있다.

#### 메시지 브로커 종류

-   ActiveMQ
-   RabbitMQ
-   Apache Kafka
-   AWS Kinesis
-   AWS SQS(Simple Queue Service)

### 메시지 브로커로 메시지 채널 구현

메시지 채널은 메시지 브로커마다 구현 방식이 다름.

| 메시지 브로커 | 점대점 채널     | 발행-구독 채널                    |
| :------------ | :-------------- | :-------------------------------- |
| JMS           | 큐              | 토픽                              |
| 아파치 카프카 | 토픽            | 토픽                              |
| AMQP 브로커   | 익스체인지 + 큐 | 팬아웃 익스체인지, 컨슈머 개별 큐 |
| AWS 키네시스  | 스트림          | 스트림                            |
| AWS SQS       | 큐              | -                                 |

### 브로커 기반 메시징의 장단점

#### 장점

-   느슨한 결합: 클라이언트는 적절한 채널에 그냥 메시지를 보내는 식으로 요청
-   메시지 버퍼링: 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링
-   유연한 통신: 모든 상호 작용 스타일을 지원
-   명시적 IPC: RPC 메커니즘은 원격 서비스가 마치 자신이 로컬 서비스인 양 호출을 시도.

#### 단점

-   성능 병목 가능성: 서능 병목점이 될 위험.
-   단일 장애점 가능성: 가용성이 높아야 한다.
-   운영 복잡도 부가: 설치, 구성, 운영해야 한다.

<br />

## 3.3.5 수신자 경합과 메시지 순서 유지

1. 샤딩(파티셔닝)된 채널은 복수의 샤드로 구성되며, 각 샤드는 채널처럼 작동
2. 송신자는 메시지 헤더에 샤드 키를 지정
3. 메시지 브로커는 메시지를 샤드 키별로 샤드/파티션에 배정
4. 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급
5. 메시지 브로커는 각 샤드를 하나의 수신자에 배정하고, 수신자가 시동/종료하면 샤드를 재배정.
   <img src="https://thebook.io/img/007035/137.jpg" width="100%">

<br />

## 3.3.6 중복 메시지 처리

메시지 브로커는 보통 적어도 한 번 이상 메시지를 전달.

-   클라이언트나 네트워크 또는 브로커 자신이 실패할 경우, 같은 메시지를 여러 번 전달할 수 있음.
    <br />

### 중복 메시지를 처리하는 방법

-   멱등한 메시지 핸들러를 작성
-   메시지를 추적하고 중복을 솎아 낸다.

### 멱등한 메시지 핸들러 작성

멱등하다: 동일한 입력 값을 반복 호출해도 아무런 부수 효과가 없을 때를 의미.

-   메시지를 다시 전송하면 순서를 보장하지 않는 메시지 브로커를 사용중일 수도 있어 종복 메시지와 순서가 안 맞는 메시지는 오류를 일으키기 때문에 중복 메시지를 솎아 내는 메시지 핸들러가 필요.

### 메시지 추적과 중복 메시지 솎아내기

-   컨슈머가 메시지 ID를 이용하여 메시지 처리 여부를 추적하면서 중복 메시지를 제거.
-   컨슈머는 처리된 메시지 ID를 DB 테이블에 기록해서 중복 메시지를 제거.

<br />

## 3.3.7 트랜잭셔널 메시징

보통 DB를 업데이트하는 트랜잭션의 일부로 메시지를 발행.

-   DB 업데이트와 메시지 전송을 한 트랜잭션으로 묶지 않을 시, DB 업데이트 후 메시지는 아직 전송되지 않은 상태에서 서비스가 중단될 수 있다.

### DB 테이블을 메시지 큐로 활용

RDBMS 기반의 애플리케이션: DB 테이블을 임시 메시지 큐로 사용하는 트랜잭셔널 아웃박스 패턴.

-   이벤트나 메시지를 DB에 있는 아웃박스에 저장해서 DB 트랜잭션의 일부로 발행.

### 메시지를 DB에서 메시지 브로커로 옮기는 방법

-   이벤트 발행: 폴링 발행기 패턴

    -   메시지 릴레이로 테이블을 폴링해서 미발행 메시지를 조회.
        ```sql
        SELECT * FROM OUTBOX ORDERED BY ... ASC
        ```
        ```sql
        BEGIN
        DELETE FROM OUTBOX WHERE ID in (...)
        COMMIT
        ```
    -   자주 폴링하면 비용 유발.

-   이벤트 발행: 트랜잭션 로그 테일링 패턴
    -   메시지 릴레이로 DB 트랜잭션 로그를 테일링 하는 방법.
    -   트랜잭션 로그를 테일링하여 DB에 반영된 변경분을 발행한다.
    -   디비지움(Debezium): DB 변경분을 아파치 카프카 메시지 브로커에 발해하는 오픈 소스 프로젝트
    -   링크트인 데이터버스(LinkedIn Databus): 오라클 트랜잭션 로그를 마이닝하여 변경분을 이벤트로 발행하는 오픈 소스 프로젝트.
    -   DynamoDB 스트림즈: 최근 24시간 동안 DynamoDB 테이블 아이템에 적용된 변경분을 시간 순으로 정렬한 데이터를 갖고 있다.
    -   이벤추에이트 트램(Eventuate Tram): 오픈 소스 트랜잭션 메시징 라이브러리. 아파치 카프카로 발행.

<br />

## 3.3.8 메시징 라이브러리/프레임워크

메시지 브로커의 클라이언트 라이브러리

-   API에 메시지를 발행하는 비즈니스 로직이 클라이언트 라이브러리와 결합
-   대부분 저수준, 메시지를 주고받는 코드가 꽤 긴 편
-   고수준의 상호 작용 스타일 지원 안함.

### 이벤추에이트 트램

-   트랜잭셔널 메시징: 메시지를 DB 트랜잭션의 일부로 발행
-   중복 메시지 감지: 컨슈머가 중복 메시지를 솎아 냄. 컨슈머가 메시지를 한 번만 처리하도록 보장.

## 개념정리

1. [RPC](https://velog.io/@jakeseo_me/RPC%EB%9E%80)
2. ACK: Acknowledgement. 송신된 메세지가 수신측에서 정상적으로 수신되었음을 송신측으로 확인응답하는 것

## 질문사항

1. 지연시간이 매우 짧은 브로커의 설명만 봤을 때 어떤 상황에서 사용할 수 있을지 감이 안옵니다. 메시지 전달이 보장되지 않는다면 보장이 될 수 있도록 따로 구현을 해야하나요?
   또한 메시징 순서 유지가 필수 요건이라고 되어 있는데 지연시간이 매우 짧은 브로커는 그러하지 않다면 이 또한 따로 구현을 해야하나요?

```
브로커마다 다 일장일단이 있습니다.
지연시간이 매우 짧은 브로커는 메시지 순서가 유지되지 않거나
메시지 전달이 보장되지 않는다든지, 아니면 메시지를 메모리에만 저장한다든지 하는 단점이 있습니다.
반대로 메시지 전달을 보장하고 메시지를 디스크에 확실히 저장하는
브로커는 지연시간이 긴 편이죠.
...
하지만 메시징 순서 유지 및 확장성은 필수 요건입니다.
```
