# 이벤트 소싱 응용 비즈니스 로직 개발

이벤트 소싱: 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장.

<br />

## 이벤트 소싱의 장단점

### 장점

-   애그리거트 이력이 보존되므로 감사/통제 용도
-   도메인 이벤트를 확실하게 발행할 수 있어 마이크로서비스 아키텍처에서 유용

### 단점

-   비즈니스 로직을 작성하는 방법이 특이해서 학습시간이 필요
-   이벤트 저장소를 쿼리하기가 쉽지 않아 CQRS 패턴 적용 필요

<br />

## 6.1.1 기존 영속화의 문제점

### 기존 영속화 방식

-   클래스는 DB 테이블에, 클래스 필드는 테이블 컬럼에, 클래스 인스턴스는 테이블 각 로그에 매핑
-   일반적으로 JPA 같은 ORM 프레임워크나 마이바티스(MyBATIS) 등의
    저수준 프레임워크 사용

### 기존 영속화 방식 단점

-   객체-관계 임피던스 부정합(object-Relational impedance mismatch)
-   애그리거트 이력이 없음.
-   감사 로깅을 구현하기가 번거롭고 에러가 자주 남.
-   이벤트 발행 로직이 비즈니스 로직에 추가됨.

### 객체-관계 임피던스 부정합

-   테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델의 그래프 구조의 근복적인 개념이 다름
-   객체-관계 매핑(ORM) 프레임워크의 타탕성

### 애그리거트 이력이 없다.

-   기존 영속화 매커니즘은 현재 애그리거트 상태만 저장하기 때문에 업데이트되면 이전 상태는 사라짐.
-   개발자가 직접코드로 구현하거나, 비즈니스 로직과 동기화해야 되는 코드를 중복 생성하게 됨.

### 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다.

-   어느 사용자가 애그리거트를 변경했는지 감사로그를 남겨 추적.
-   감사로깅 구현시간이 걸리는 문제
-   감사 로깅 코드 및 비즈니스 로직이 걔속 분화하여 버그 가능성 높음.

### 이벤트 발행 로직이 비즈니스 로직에 추가된다.

-   도메인 이벤트 발행을 지원하지 않음.
-   ORM 프레임워크는 데이터 객체가 변경될 때 애플리케이션이 제공한 콜백을 호출할 수 있지만, 데이터를 업데이트하는 트랜잭션의 일부로 메시지를 자동 발행하는 기능 따위는 없음.

<b>도메인 이벤트</b>: 애그리거트가 자신의 상태를 변경한 후 발행하는 이벤트

<br />

## 6.1.2 이벤트 소싱 개요

-   이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장
-   각 이벤트는 애그리거트의 상태 변화를 나타냄
-   애그리거트의 비즈니스 로직은 이벤트를 생산/소비하는 요건 중심으로 구성

### 이벤트를 이용하여 애그리거트를 저장

-   애그리거트를 DB에 있는 이벤트 저장소에 일련의 이벤트로 저장.
-   이벤트 소싱은 각 애그리거트를 일련의 이벤트로 저장
-   RDBMS 기반 애플리케이션은 EVENTS 테이블에 이벤트를 보관.
-   이벤트를 가져와 재연하는 방식으로 애그리거트의 인-메모리 상태를 다시 살려내는 것은 JPA나 하이버네이트 같은 ORM 프레임워크가 엔터디를 로드하는 방법과 비슷

#### 작업순서

1. 애그리거트의 이벤트를 로드
2. 기본 생성자를 호출하여 애그리거트 인스턴스를 생성
3. 이벤트를 하나씩 순회하며 apply()를 호출

### 이벤트는 곧 상태 변화

-   이벤트 소싱은 주로 애그리거트에 의해 이벤트 및 구조가 결정
-   생성을 비롯한 모든 애그리거트의 상태 변화를 도메인 이벤트로 나타내며 애그리거트는 상태가 바뀔 때마다 반드시 이벤트 발생
-   이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 데이터를 갖고 있어야 함.

### 애그리거트 메서드의 관심사는 오직 이벤트

비즈니스 로직은 애그리거트의 업데이트 요청을 애그리거트 루트에 있는 커맨드 메서드를 호출하여 처리

-   `[그림 6-4]` 커맨드를 처리하면 애그리거트 상태 변경 없이 이벤트가 생성되고 애그리거트는 이벤트를 적용해서 업데이트
-   `[그림 6-5]` 이벤트 소싱은 애그리거트를 업데이트는 하는 메서드를 (커맨드를 입력받아 이벤트를 반환하는) processor()와 (이벤트를 전달받아 애그리거트를 업데이트하는) 하나 이상의 apply()로 분리

#### 애그리거트 생성 순서

1. 기본 생성자로 애그리거트 루트를 초기화
2. process()를 호출하여 새 이벤트를 발생
3. 새 이벤트를 하나씩 순회하면서 apply()를 호출하여 애그리거트 업데이트
4. 이벤트 저장소에 새 이벤트를 저장

#### 애그리거트 업데이트 순서

1. 이벤트 저장소에서 애그리거트 이벤트 로드
2. 기본 생성자로 애그리거트 루트 초기화
3. 가져온 이벤트를 하나씩 순회하여 애그리거트 루트의 apply()를 호출
4. process()를 호출하여 새 이벤트를 발생
5. 새 이벤트를 순회하면서 apply()를 호출하여 애그리거트 업데이트
6. 이벤트 저장소에 새 이벤트를 저장

### 이벤트 소싱 기반의 Order 애그리거트

-   JPA 버전처럼 필드와 이벤트가 거의 비슷하지만, 이벤트를 발생시키고 그 이벤트를 적용하여 상태를 업데이트하는 방식으로 비즈니스 로직을 구현
-   JPA 기반: createOrder(), revise(), confirmRevision(), rejectRevision() 등등
-   이벤트 소싱 기반 코드: 모두 process(), apply()로 대체

<br />

## 6.1.3 동시 업데이트: 낙관적 잠금

이벤트에 딸려 온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤트를 삽입할 때 이벤트 저장소가 버전 변경 여부 체크

-   이벤트 번호를 버전 번호로 사용해도 되고, 이벤트 저장소에서 명시적으로 버전 번호를 관리해도 됨.

 <br />

## 개념

-   폴드(fold) 또는 리듀스(reduce): 연산(operation)과 누산기(accumulator)로 컬렉션에 있는 값들을 처리하여 더 작은 컬렉션이나 단일 값을 생성하는 작업. -> 함수형 프로그래밍
    -   [참고자료](https://futurecreator.github.io/2018/10/07/functional-programming-filter-map-fold-reduce/)

<br />

## Reference

-   [객체지향 모델과 관계형 모델의 패러다임의 불일치](https://coco-log.tistory.com/155)

## 질문사항

1. 도메인 이벤트가 `django`에서의 `signal` 인건가요?? 아니면 단순한 애플리케이션이 제공하는 콜백호출인가요?

2. [page246] 애그리거트를 이벤트로 저장히기 때문에 상태 변경에 필요한 데이터를 갖고 있어야 하는 것에 동의하는데 예시중에 OrderCreatedEvent 가 발생할 시 많은 데이터를 가지고 있어야 되는데 효율적이라고 볼 수 있나요?
