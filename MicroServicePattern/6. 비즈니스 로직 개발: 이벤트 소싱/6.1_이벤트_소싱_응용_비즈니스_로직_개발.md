# 이벤트 소싱 응용 비즈니스 로직 개발

이벤트 소싱: 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장.

<br />

## 이벤트 소싱의 장단점

### 장점

-   애그리거트 이력이 보존되므로 감사/통제 용도
-   도메인 이벤트를 확실하게 발행할 수 있어 마이크로서비스 아키텍처에서 유용

### 단점

-   비즈니스 로직을 작성하는 방법이 특이해서 학습시간이 필요
-   이벤트 저장소를 쿼리하기가 쉽지 않아 CQRS 패턴 적용 필요

<br />

## 6.1.1 기존 영속화의 문제점

### 기존 영속화 방식

-   클래스는 DB 테이블에, 클래스 필드는 테이블 컬럼에, 클래스 인스턴스는 테이블 각 로그에 매핑
-   일반적으로 JPA 같은 ORM 프레임워크나 마이바티스(MyBATIS) 등의
    저수준 프레임워크 사용

### 기존 영속화 방식 단점

-   객체-관계 임피던스 부정합(object-Relational impedance mismatch)
-   애그리거트 이력이 없음.
-   감사 로깅을 구현하기가 번거롭고 에러가 자주 남.
-   이벤트 발행 로직이 비즈니스 로직에 추가됨.

### 객체-관계 임피던스 부정합

-   테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델의 그래프 구조의 근복적인 개념이 다름
-   객체-관계 매핑(ORM) 프레임워크의 타탕성

### 애그리거트 이력이 없다.

-   기존 영속화 매커니즘은 현재 애그리거트 상태만 저장하기 때문에 업데이트되면 이전 상태는 사라짐.
-   개발자가 직접코드로 구현하거나, 비즈니스 로직과 동기화해야 되는 코드를 중복 생성하게 됨.

### 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다.

-   어느 사용자가 애그리거트를 변경했는지 감사로그를 남겨 추적.
-   감사로깅 구현시간이 걸리는 문제
-   감사 로깅 코드 및 비즈니스 로직이 걔속 분화하여 버그 가능성 높음.

### 이벤트 발행 로직이 비즈니스 로직에 추가된다.

-   도메인 이벤트 발행을 지원하지 않음.
-   ORM 프레임워크는 데이터 객체가 변경될 때 애플리케이션이 제공한 콜백을 호출할 수 있지만, 데이터를 업데이트하는 트랜잭션의 일부로 메시지를 자동 발행하는 기능 따위는 없음.

<b>도메인 이벤트</b>: 애그리거트가 자신의 상태를 변경한 후 발행하는 이벤트

<br />

## 6.1.2 이벤트 소싱 개요

-   이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장
-   각 이벤트는 애그리거트의 상태 변화를 나타냄
-   애그리거트의 비즈니스 로직은 이벤트를 생산/소비하는 요건 중심으로 구성

### 이벤트를 이용하여 애그리거트를 저장

-   애그리거트를 DB에 있는 이벤트 저장소에 일련의 이벤트로 저장.
-   이벤트 소싱은 각 애그리거트를 일련의 이벤트로 저장
-   RDBMS 기반 애플리케이션은 EVENTS 테이블에 이벤트를 보관.
-   이벤트를 가져와 재연하는 방식으로 애그리거트의 인-메모리 상태를 다시 살려내는 것은 JPA나 하이버네이트 같은 ORM 프레임워크가 엔터디를 로드하는 방법과 비슷

#### 작업순서

1. 애그리거트의 이벤트를 로드
2. 기본 생성자를 호출하여 애그리거트 인스턴스를 생성
3. 이벤트를 하나씩 순회하며 apply()를 호출

### 이벤트는 곧 상태 변화

-   이벤트 소싱은 주로 애그리거트에 의해 이벤트 및 구조가 결정
-   생성을 비롯한 모든 애그리거트의 상태 변화를 도메인 이벤트로 나타내며 애그리거트는 상태가 바뀔 때마다 반드시 이벤트 발생
-   이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 데이터를 갖고 있어야 함.

### 애그리거트 메서드의 관심사는 오직 이벤트

비즈니스 로직은 애그리거트의 업데이트 요청을 애그리거트 루트에 있는 커맨드 메서드를 호출하여 처리

-   `[그림 6-4]` 커맨드를 처리하면 애그리거트 상태 변경 없이 이벤트가 생성되고 애그리거트는 이벤트를 적용해서 업데이트
-   `[그림 6-5]` 이벤트 소싱은 애그리거트를 업데이트는 하는 메서드를 (커맨드를 입력받아 이벤트를 반환하는) processor()와 (이벤트를 전달받아 애그리거트를 업데이트하는) 하나 이상의 apply()로 분리

#### 애그리거트 생성 순서

1. 기본 생성자로 애그리거트 루트를 초기화
2. process()를 호출하여 새 이벤트를 발생
3. 새 이벤트를 하나씩 순회하면서 apply()를 호출하여 애그리거트 업데이트
4. 이벤트 저장소에 새 이벤트를 저장

#### 애그리거트 업데이트 순서

1. 이벤트 저장소에서 애그리거트 이벤트 로드
2. 기본 생성자로 애그리거트 루트 초기화
3. 가져온 이벤트를 하나씩 순회하여 애그리거트 루트의 apply()를 호출
4. process()를 호출하여 새 이벤트를 발생
5. 새 이벤트를 순회하면서 apply()를 호출하여 애그리거트 업데이트
6. 이벤트 저장소에 새 이벤트를 저장

### 이벤트 소싱 기반의 Order 애그리거트

-   JPA 버전처럼 필드와 이벤트가 거의 비슷하지만, 이벤트를 발생시키고 그 이벤트를 적용하여 상태를 업데이트하는 방식으로 비즈니스 로직을 구현
-   JPA 기반: createOrder(), revise(), confirmRevision(), rejectRevision() 등등
-   이벤트 소싱 기반 코드: 모두 process(), apply()로 대체

<br />

## 6.1.3 동시 업데이트: 낙관적 잠금

이벤트에 딸려 온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤트를 삽입할 때 이벤트 저장소가 버전 변경 여부 체크

-   이벤트 번호를 버전 번호로 사용해도 되고, 이벤트 저장소에서 명시적으로 버전 번호를 관리해도 됨.

<br />

## 6.1.4 이벤트 소싱과 이벤트 발행

### 이벤트 발행: 폴링

-   이벤트 발행기는 SELECT 문으로 새 이벤트를 계속 폴링하면서 메시지 브로커에 발행

#### 문제점

-   어느 이벤트가 새 이벤트인지 분간하는 일이 필요
    -   EVENT_ID 가 단순히 1만큼 증가한다면, 이벤트 발행기가 자신이 처리한 마지막 EVENT_ID를 기록
-   트랜잭션이 이벤트를 발생시키는 순서와 다르게 커밋할 수 있는 문제점 발생
    -   EVENTS 테이블에 이벤트 발행 여부를 추적할 수 있는 컬럼을 추가
    1. 미발행 이벤트 검색
    ```sql
    SELECT * FROM EVENTS WHERE PUBLISHED = 0 ORDER BY EVENT_ID ASC
    ```
    2. 메시지 브로커에 이벤트를 발행
    3. 이벤트가 발행된 것으로 표시
    ```sql
    UPDATE EVENTS SET PUBLISHED = 1 WHERE EVENT_ID = ?
    ```

### 이벤트 발행: 트랜잭션 로그 테일링

-   이벤트 발행을 확실히 보장하면서도 성능/확장성이 우수

<br />

## 6.1.5 스냅샷으로 성능 개선

### 스냅샷의 사용이유

-   수명인 긴 애그리거트의 경우 이벤트 수가 꽤 많기 때문에 일일이 로드/폴드 하기가 어려움

### 스냅샷

-   주기적으로 애그리거트 상태의 스냅샷을 저장하고 가장 최근에 뜬 스냅샷과 그 이후 발생한 이벤트만 가져오는 식으로 애그리거트 상태를 복원
-   `[그림 6-7]` 모든 이벤트를 로드할 필요가 없어서 성능이 개선
-   스냅샷 버전이 `N`이면 `N+1` 이후에 발생한 이벤트 2개만 가져오면 됨.

### 스냅샷 형태

-   복잡한 애그리거트라면 메멘토 패턴
-   단순하고 직렬화하기 쉬운 구조의 애그리거트라면 JSON 직렬화 형태로

<br />

## 6.1.6 멱등한 메시지 처리

메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발해야 한다.

### RDBMS 이벤트 저장소 사용

#### 중복 메시지를 솎아 내는 방법

-   메시지 ID: PROCESSED_MESSAGES 테이블에
-   이벤트: EVENTS 테이블에 삽입하는 트랜잭션의 일부로 삽입

### NoSQL 이벤트 저장소 사용

-   NoSQL 기반의 이벤트 저장소는 트랜잭션 모델이 제한적이기 때문에 메시지를 멱등하게 처리하려면 다른 수단이 필요
    -   <b>해결</b>: 메시지 컨슈머가 메시지 처리 도중 생성된 메시지 ID를 저장함으로써 해당 메시지 ID가 애그리거트의 이벤트에 있는지 확인하여 중복 메시지 여부 파악
-   메시지 처리 결과 아무 이벤트도 생성되지 않을 경우 오류 발생
    -   <b>해결</b>: 항상 이벤트를 발행.
        -   애그리거트가 이벤트를 발생시키지 않을 경우, 오직 메시지 ID를 기록할 목적으로 가짜 이벤트(pseudo event)를 저장

<br />

## 6.1.7 도메인 이벤트 발전시키기

이벤트 소싱은 `정확성`을 담보로 `변경 감사 로그`를 제공하여 애플리케이션이 애그리거트 상태를 온전히 재구성할 수 있는 반면, 이벤트 구조는 `시간`이 흐름에 따라 계속 달라지기 때문에 새로운 문제가 생긴다.

### 이벤트 스키마

#### 이벤트 소싱에 기반한 애플리케이션의 스키마

-   하나 이상의 애그리거트로 구성
-   각 애그리거트가 발생시키는 이벤트를 정의
-   이벤트 구조를 정의

#### 애플리케이션 이벤트가 발전할 수 있는 다양한 경로

`[표 6-1]` 참고

### 업캐스팅을 통한 스키마 변화 관리

-   SQL DB 세계에서 DB 스키마 변경은 보통 마이그레이션으로 작업
    -   스키마 마이그레이션은 버전 관리 시스템에 저장하고 플라이웨이 등의 툴을 써서 DB 에 반영
-   이벤트 소싱 애플리케이션에서는 이벤트를 새 버전의 스키마에 마이그레이션 하는 것이 아니라, 이벤트 소싱 프레임워크가 이벤트 저장소에서 이벤트를 로드할 때 바꾸어줌.
-   업캐스터(upcaster) 컴포넌트가 개별 이벤트를 구 버전에서 신 버전으로 업데이트

<br />

## 6.1.8 이벤트 소싱의 장점

### 도메인 이벤트를 확실하게 발행

-   애그리거트 상태가 변경될 때마다 확실히 이벤트를 발행
-   변경을 일으킨 사용자 신원을 이벤트마다 저장하므로 정확한 감사 로구 제공

### 애그리거트 이력 보존

-   애그리거트마다 전체 이력이 그대로 보존
-   애그리거트의 과거 상태를 임시 쿼리로 쉽게 조회 가능

### O/R 임피던스 불일치 문제를 거의 방지

애그리거트와 애그리거트를 직렬화한 표현형 사이를 한 수준 더 간접화(indirection)

### 개발자에게 타임 머신 제공

이벤트 소싱은 애플리케이션 가동 중 발생한 모든 일을 기록

<br />

## 6.1.9 이벤트 소싱의 단점

### 새로운 프로그래밍 모델을 배우려면 시간이 걸린다

-   초기학습 시간 필요
-   기존 애플리케이션에 적용하려면 비즈니스 로직을 재구성해야 함.

### 메시징 기반 애플리케이션은 복잡하다.

-   메시지 브로커가 적어도 1회 이상 전달하기 때문에 멱등하지 않은 이벤트 핸들러는 중복 이벤트를 감지해 걸러 내야 함.

### 이벤트를 발전시키기 어렵다

-   애그리거트는 각 스키마 버전별로 이벤트를 폴드해야 하기 때문에 버전마다 분기 처리하는 코드로 애그리거트가 도배될 가능성이 높음.
-   <b>해결</b>: 이벤트를 이벤트 저장소에서 가져올 때 최신 버전으로 업그레이드

### 데이터를 삭제하기 어렵다

-   애플리케이션은 반드시 이메일 주소 같은 사용자 개인 정보를 망각하는 기능을 갖추어야 한다는 규정을 준수해야 할 경우
-   암호화로 해결
-   `가명화(pseudonymization)`: 이메일 주소를 UUID 토큰으로 바꾸고 이것을 애그리거트 ID처럼 사용

### 이벤트 저장소를 쿼리하기 어렵다.

-   해당하는 컬럼이 없을 시 신용한도를 설청한 이후 업데이트한 이벤트를 폴드해서 신용한도를 계산해야 함. - `SELECT`문이 중첩된 매우 복잡하고 비효율적인 쿼리
-   NoSQL 이벤트 저장소는 대부분 기본키만 검색 지원되므로 CQRS 방식으로 쿼리 구현

<br />

## 개념

-   <b>폴드(fold) 또는 리듀스(reduce)</b>: 연산(operation)과 누산기(accumulator)로 컬렉션에 있는 값들을 처리하여 더 작은 컬렉션이나 단일 값을 생성하는 작업. -> 함수형 프로그래밍
    -   [참고자료](https://futurecreator.github.io/2018/10/07/functional-programming-filter-map-fold-reduce/)
-   <b>메멘토 패턴</b>: 메멘토 패턴은 객체의 상태 정보를 저장하고 사용자의 필요에 의하여 원하는 시점의 데이터를 복원 할 수 있는 패턴을 의미합니다.
    -   [참고자료](https://lktprogrammer.tistory.com/65)

<br />

## Reference

-   [객체지향 모델과 관계형 모델의 패러다임의 불일치](https://coco-log.tistory.com/155)
-   [플라이웨이](https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-flyway-db-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-tool/)
-   [Programming/Java[자바, Java] 캐스팅 - 업캐스팅(Upcasting), 다운캐스팅(Downcasting)](https://computer-science-student.tistory.com/335#:~:text=%EC%97%85%EC%BA%90%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80%20%EC%9E%90%EC%8B%9D%20%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%9E%90%EC%8B%9D%20%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94%20Student%EC%9D%B4%EB%8B%A4.&text=p%EA%B0%80%20Student%20%EA%B0%9D%EC%B2%B4%EB%A5%BC,%EC%97%90%EB%A7%8C%20%EC%A0%91%EA%B7%BC%EC%9D%B4%20%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4.)
-   [객체지향 모델과 관계형 모델의 패러다임의 불일치](https://coco-log.tistory.com/155)

## 질문사항

1. 도메인 이벤트가 `django`에서의 `signal` 인건가요?? 아니면 단순한 애플리케이션이 제공하는 콜백호출인가요?

-> method에 얽매이지 않고 이벤트에 초점을 맞추자
-> Signal 은 구현 클래스에서 처리할 수 있는 방법중의 하나


2. [page246] 애그리거트를 이벤트로 저장히기 때문에 상태 변경에 필요한 데이터를 갖고 있어야 하는 것에 동의하는데 예시중에 OrderCreatedEvent 가 발생할 시 많은 데이터를 가지고 있어야 되는데 효율적이라고 볼 수 있나요?

-> 멱등성을 보장하기 위한 방법으로 생각.
