# 6.3 사가와 이벤트 소싱을 접목

사가와 이벤트 소싱 기반의 비즈니스 로직을 연계.

-   이벤트 소싱에서는 코레오그래피 사가를 쉽게 이용
-   이벤트 소싱 기반의 비즈니스 로직을 오케스트레이션 기반의 사가에 연계하는 일은 어려움.
    -   이벤트 저장소의 트랜잭션 개념이 상당히 제한적

### 사가에서 반드시 원자적으로 수행되어야 하는 액션

-   <b>사가 생성</b>: 사가를 시작한 서비스는 원자적으로 애그리거트를 생성/수정하고 사가 오케스트레이터를 생성해야 한다.
-   <b>사가 오케스트레이션</b>: 사가 오케스트레이터는 원자적으로 응답을 소비하고, 자신의 상태를 업데이트한 후 커맨드 메시지를 전송해야 한다.
-   <b>사가 참여자</b>: 사가 참여자는 원자적으로 메시지를 소비하고, 중복 메시지를 솎아 내고, 애그리거트를 생성/수정하고, 응답 메시지를 전송해야 한다.

-   이벤트 저장소의 RDBMS/NoSQL 사용 여부는 이벤트 소싱과 오케스트레이션 사가의 연계 가능성을 가늠하는 핵심 기준

<br />

## 6.3.1 코레오그래피 사가 구현: 이벤트 소싱

이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 사가를 쉽게 구현 가능

### 방법

1. 애그리거트가 업데이트되면 사가가 이벤트를 발생시킴.
2. 제각기 배정된 이벤트 핸들러는 해당 이벤트를 소비한 후 애그리거트를 업데이트
3. 이벤트 소싱 프레임워크는 각 이벤트 핸들러를 알아서 멱등하게 만듬.

### 장점

-   이벤트 소싱은 메시징 기반의 IPC, 메시지 중복 제거, 원자적 상태 업데이트와 메시지 전송 등 사가가 필요로 하는 여러가지 매커니즘 제공

### 단점

-   이벤트의 목적이 이원화됨.
-   이벤트 소싱은 상태 변화를 나타내기 위해 이벤트를 이용하지만 이벤트를 사가 코레오그래피에 적용시 애그리거트는 상태 변화가 없어도 무조건 이벤트를 발생시켜야 함.

<b>`결론은 오케스트레이션 사가를 구현하자!!`</b>

<br />

## 6.3.2 오케스트레이션 사가 생성

-   서비스는 첫번째 액션이 수행되면 두번째 액션은 최종적으로 실행되는 방식으로 수행하며 두 액션은 서비스에서 반드시 수행되도록 보장하는 방법은 이벤트 저장소의 종류마다 다름

### 사가 오케스트레이터 작성: RDBMS 이벤트 저장소 사용 서비스

RDBMS 이벤트 저장소를 사용하는 서비스에서는 이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 작업을 한 트랜잭션으로 묶을 수 있음.

### 사가 오케스트레이터 작성: NoSQL 이벤트 저장소 사용 서비스

-   NoSQL 이벤트 저장소를 사용하는 서비스는 이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 액션을 원자적으로 수행할 수 없다.

#### 해결방안

-   서비스는 애그리거트가 발생시킨 도메인 이벤트에 반응하여 사가 오케스트레이터를 생성하는 이벤트 핸들러를 갖고 있어야 한다.
    -   중복 이벤트를 처리해야 함.

#### 사가 인스턴스를 하나만 생성하는 방법

-   이벤트의 유일한 속성에서 사가 ID 추출

1. 이벤트를 발생시킨 `애그리거트 ID`를 `사가 ID`로 사용
2. 이벤트 ID를 사가 ID로 사용

<br />

## 6.3.3 이벤트 소싱 기반의 사가 참여자 구현

이벤추에이트 트램 프레임워크와 동일한 트랜잭션으로 묶을 수 없는 이벤트 저장소를 이용하는 서비스는 이슈가 있기에 해결해야 함.

-   커맨드 메시지를 멱등하게 처리
-   응답 메시지를 원자적으로 전송

### 커맨드 메시지를 멱등하게 처리

-   이벤트 소싱 기반의 사가 참여자가 중복 메시지를 솎아 낼 수 있는 수단 마련

### 응답 메시지를 원자적으로 전송

1. 사가 커맨드 핸들러가 애그리거트를 생성/수정할 때, 애그리거트가 발생시킨 진짜 이벤트와 가짜 이벤트 SagaReplyRequested를 모두 이벤트 저장소에 저장
2. SagaReplyRequested 이벤트 핸들러는 이벤트에 포함된 데이터로 응답 메시지를 만들어 사가 오케스트레이터의 응답 채널에 출력

### 예제: 이벤트 소싱 기반의 사가 참여자

`[P.277] 그림 6-12 이벤트 소싱 기반의 회계 서비스가 주문 생성 사가에 참여하는 과정`

<br />

## 6.3.4 사가 오케스트레이터 구현: 이벤트 소싱

### 설계이슈

1.  사가 오케스트레이터를 어떻게 저장할 것인가?
2.  어떻게 오케스트레이터 상태를 원자적으로 변경하고 커맨드 메시지를 전송할 것인가?
3.  어떻게 사가 오케스트레이터가 정확히 한 번만 메시지를 응답하게 만들 것인가?

### 이벤트 소싱으로 사가 오케스트레이터 저장

#### Event

아래의 이벤트들은 사가 오케스트레이터의 상태 재구성에 필요한 데이터를 가지고 있음.

-   SagaOrchestratorCreated: 사가 오케스트레이터가 생성되었습니다.
-   SagaOrchestratorUpdated: 사가 오케스트레이터가 수정되었습니다.

### 커맨드 메시지를 확실하게 전송

-   전송할 커맨드를 나타낸 `SagaCommandEvent`를 저장
-   이벤트 핸들러는 이벤트를 구독해서 적절한 채널로 각 커맨드 메시지를 전송

#### 커맨드 전송 단계

-   적어도 `1회` 이상은 커맨드 전송
-   중복 커맨드 메시지 발생시 `SagaCommandEvent의 ID`(유일성 보장를 커맨드 메시지 ID로 이용

1. 사가 오케스트레이터가 전송하려는 각 커맨드마다 SagaCommandEvent를 발생
    - SagaCommandEvent에는 목적지 채널, 커맨드 객체 등 커맨드 전송에 필요한 데이터가 모두 담겨 있으며 이런 이벤트는 이벤트 저장소에 저장
2. 이벤트 핸들러는 SagaCommandEvent 처리 후 커맨드 메시지를 목적지 메시지 채널로 보냄.

### 응답을 꼭 한번만 처리

-   중복된 메시지를 솎아낼 필요가 있다.
-   오케스트레이터가 응답 메시지 ID를 (응답을 처리할 때 오케스트레이터가 발생시킬) 이벤트에 보관하여 어느 메시지가 중복인지 쉽게 분간한다.
