# 1.1 서서히 모놀리식 지옥에 빠져들다

## FTGO Application Architecture

### 문제점

-   하나의 WAR 파일로 구성된 모놀리스 방식
-   Big Ball of Mud pattern 과 스파케티 코드 범벅 패턴
-   소프트웨어 전달 페이지의 속도 느려짐과 한물간 프레임워크 사용으로 인한 문제 발생

### FTGO 구조

-   비지니스 로직 : 각자가 도메인 객체 컬렉션인 모듈로 구성되며, 어댑터가 있는 방식
    -   인바운드 어댑터: 비지니스 요청을 호출하여 처리(ex: REST API, 웹 UI 어댑터 등)
    -   아웃바운드 어댑터: DB 접속 또는 클라우드 서비스를 호출하여 처리(MySQL, 트윌리오, 스트라이프)

### 작은 규모의 모놀리식 아키텍처 장점

-   개발이 간단하다.
-   애플링케이션을 쉽게 변경할 수 있다.
-   테스트하기 쉽다.
-   배포하기 쉽다.
-   확장하기 쉽다.

### 모놀리식 아키텍처의 문제점

-   너무 복잡해서 개발자가 주눅 들다.
    -   내용이 방대하여 버그를 고치고 새 기능을 구현하기에 시간이 오래 걸린다.
    -   코드 커밋부터 프로덕션까지 과정이 길고 험난하며 수동으로 테스트한다.
        <br />-> 크고, 복잡, 불안, 관리하기 어려움.
    -   하위로 내려갈수록 복잡성 증가
    -   코드베이스도 어려운데, 변경분을 정확하게 반영하기 어려움.
    -   변경될때마다 코드베이스가 한층 더 복잡하고 난해한 코드로 뒤덮임.
-   개발이 더디다.
    -   개발자 IDE의 실행 속도 감소와 빌드시간이 오래 걸림.
-   커밋부터 배포에 이르는 길고 험난한 여정
    -   SaaS 애플리케이션의 최근 트렌드인 지속적 배포를 하기에 적합하지 않음.
    -   한팀이 스프린트를 마치면 곧바로 테스트 및 코드 안정화 기간이 필요.
    -   테스트 시간이 너무 길어 변경분을 프로덕션에 반영하는데 시간이 많이 걸림.
-   확장하기 어렵다.
    -   같은 애플리케이션이라도 리소스 요건이 상이한 모듈이 존재하므로 서버 구성 시 리소스 분배를 신경써야 된다.
    -   데이터 용량이 우선시 될때는 인-메모리 DB 형태로 저장되기 때문에 메모리 칩이 많이 장착된 서버에 배포, 이미지 처리 모듈은 CPU 코어 수가 많은 서버에 배포하는 것이 좋음.
-   모놀리스는 확실하게 전달하기 어렵다.
    -   신뢰성 부족
    -   테스트 하기 어려움, 테스트성이 부족하여 프로덕션에 버그가 발생할 가능성이 높음.
-   갈수록 한물간 기술 스택에 발목이 붙잡히다.
    -   새로운 프레임워크, 새로운 프로그래밍 언어를 받아들이기 어려움.

<br />

## 개념 정리

-   WAR : Web Archive 파일, JAR 파일과 같은 역할을 하며, 주로 Web Application을 묶는데 사용, Web Application을 어떻게 설정할지 정의한 배포 명세서(web.xml 파일)가 있다는 것.
    <br />
    [출처 : WAR? JAR? ](https://life-it.tistory.com/33)

    <br />

-   JAR과 WAR의 차이 : `JAR`는 어플리케이션 레벨(business layer), `WAR`는 웹어플리케이션 레벨(web layer)을 지원한다.
-   SaaS
    -   [Azure - SaaS란?](https://azure.microsoft.com/ko-kr/overview/what-is-saas/)
    -   [[클라우드] SaaS란? 소프트웨어의 기능을 서비스로 이용](https://m.blog.naver.com/ydot/222076883154)

<br />

## 질문사항

### 작은 규모의 모놀리식 아키텍처 장점

1. 비교적 규모가 작았을 때의 장점이기 때문에, 교모가 커졌을 때는 이러한 장점들이 사라진다고 생각이 됩니다. 결국에 규모가 작은 경우에는 모놀리식 아키텍처가 더 유리한 경우가 있다고 생각이 드는데 이러한 규모를 판단할 수 있는 기준은 어떻게 내릴수 있을까요?

<br />

2. 애플리케이션을 쉽게 변경할 수 있다고 명시되어 있고, 설명으로 코드, DB 스키마를 변경해서 빌드/배포하기 용이하다고 하였는데, 반대로 MSA에서 DB 스키마를 변경해서 빌드/배포가 어려운 점이 있을까요?

### 모놀리식 아키텍처의 문제점

1. 디펜던시를 분석하는 툴을 적용하면 개발자가 코드베이스를 이해하거나, 변경분을 정확히 반영할 수 있도록 도움을 받을 수 있다거나, 복잡성에 대한 문제점을 완화시켜줄 수 있다는 것이 솔직히 이해가 잘 되지 않는 것 같아요!

[`page32 마지막 문단 인용`]

```
최근에 참석했던 콘퍼런스에서 메리는 코드 줄 수가 수백만에 달하는 애플리케이션을 대상으로 JAR  파일 수천 개 간의 디펜던시를 분석하는 툴의 개발자와 알게 되었습니다, 그때는 FTGO에도 이 툴을 쓰면 뭔가 성과가 있을 것 같았지만, 지금 그녀는 복잡한 애플리케이션에 더 잘 어울리는 아키텍처, 즉 마이크로서비스로 갈아타는 것이 더 낫지 않나 고민중입니다.
```

### 커밋부터 배포에 이르는 길고 험난한 여정

1. 사람이 손으로 직접 테스트 해야하는 영역이라는 것이 정확히 어떤 영역을 의미하는지 이해가 조금 부족한 것 같습니다! 또한 저의 개인적인 생각이지만 CI 서버에서 전체테스트 스위트를 돌려보는 시간도 물론 들겠지만 사람이 손으로 직접 테스트하는 시간 또한 길 것이라 생각합니다. MSA로 바꿈으로서 CI 서버에서 시간이 감소된다는 점은 전적으로 동의하고 이해를 했지만 사람이 직접 손으로 테스트 하는 시간이 감소하거나 없어질 수 있는것인가요?  
   [`page33 마지막 문단 인용`]

```
코드베이스가 너무 복잡하여 변경 영향도가 제대로 파악이 안되므로 개발자는 CI 서버에서 전체 테스트 스위트를 한 번씩 돌려 보아야 합니다. 물론 사람이 손으로 직접 테스트해야 하는 영역도 있습니다. 테스트가 실패하면 원인을 찾고 조치하는 데 시간이 많이 걸리므로 테스트 한 사이클을 완료하는 데만 2~3일이나 걸립니다.
```
