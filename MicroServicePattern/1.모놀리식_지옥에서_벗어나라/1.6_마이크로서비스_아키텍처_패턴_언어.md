# 1.6 마이크로서비스 아키텍처 패턴 언어

## 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다.

-   어떤 기술을 놓고 다소 과장된 극단적인 논쟁이 벌어지는 근본적인 이유 : 본래 감정의 지배를 받기 쉬운 인간의 특성 탓.
-   `조너선 화이트<바른 마음: 나의 옳음과 그들의 옳음은 왜 다른가 >` 에서 `인간의 마음이 움직이는 모습을 코끼리와 코끼리 탄 사람에 비유`

<br />

## 1.6.2 패턴 및 패턴 언어

-   패턴: 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법.
-   패턴언어: 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합.

### 상용패턴의 구조

#### 강제조항: 문제 해결을 위해 반드시 처리해야 할 이슈

-   상충하는 강제 조항도 있기 때문에 모든 조항을 전부 충족할 수는 없고, 어느 조항이 더 중요한지는 맥락에 따라 따르므로 우선순위를 정해야한다.

#### 결과맥락: 패턴 적용 결과

-   장점: (해결된 강제 조항 등) 패턴의 좋은 점
-   단점: (미해결 강제 조항 등) 패턴의 나쁜 점
-   이슈: 패턴 적용 시 발생한 새로운 문제점

#### 연관 패턴: 다섯가지 관계 유형

-   선행자(predecessor): 이 패턴을 필요하게 만든 선행 패턴.
-   후행자(successor): 이 패턴으로 야기된 이슈를 해결하는 패턴.
-   대안(alternative): 이 패턴의 대체 솔루션을 제공하는 패턴.
-   일반화(generalization): 문제를 해결하는 일반적인 솔루션에 해당하는 패턴.
-   세분화(specialization): 특정 패턴을 더 세부적으로 나타낸 형태.

<br />

## 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요

-   마이크로서비스 아키텍처 패턴 언어: 전체 애플리케이션을 마이크로서비스 아키텍처로 구성할 때 유용한 패턴의 모음집

### 패턴 3계층

-   인프라 패턴: 주로 개발 영역 밖의 인프라 문제를 해결
-   애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제를 해결
-   애플리케이션 패턴: 개발자가 맞닥뜨리는 문제를 해결

### 애플리케이션을 여러 서비스로 분해하는 패턴

-   비지니스 능력에 따라 서비스를 구성하는 방법.
-   DDD 하위 도메인에 따라 서비스를 구성하는 방법.

### 통신 패턴

-   통신 스타일: 어떤 종류의 IPC를 사용하는가?
-   디스커버리: 서비스 클라이언트는 서비스 인스턴스의 IP를 어떻게 가져오는가?
-   신뢰성: 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가?
-   트랜잭셔널 메이징: 비지니스 데이터를 업데이트하는 DB 트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?
-   외부 API: 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?

### 트랜잭션 관리를 위한 데이터 일관성 패턴

-   서비스마다 DB를 따로 두면 문제 발생
-   기존의 분산 트랜잭션은 요즘 애플리케이션에는 맞지 않기 때문에 사가 패턴에 따라 데이터 일관성을 유지

### 데이터 쿼리 패턴

서비스마다 DB를 두면 각 서비스가 소유한 데이터를 조인하는 쿼리도 문제.

-   API 조합 패턴: 하나 이상의 서비스를 호출해서 그 결과를 조합.
-   CQRS: 하나 이상의 데이터 레플리카(복제본)을 유지해서 쉽게 쿼리하는 방식

### 서비스 배포 패턴

마이크로서비스 애플리케이션은 다양한 언어와 프레임워크로 구현된 수십~수백 개의 서비스로 이루어져 있어 배포 작업이 훨씬 더 복잡하고 관리할 가동부가 많아서 배포 패턴을 사용

-   개발자가 단순한 UI로 서비스 배포/관리, 가상머신, 컨테이너, 서버리스 기술을 응용한 배포 플랫폼

### 관측성 패턴: 애플리케이션 동작 파악

마이크로서비스 아키텍처는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없기 때문에 로그 파일 하나만으로는 원인을 파악할 수 없고 문제의 원인을 찾고 진단하기가 복잡.
지연 시간도 짚어보아야 할 대상이 많아 원인을 특정하기가 까다로움.

-   헬스 체크(health check) API: 서비스 헬스를 반환하는 Endpoint를 표출.
-   로그 수집(log aggregation): 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공
-   분산 추적: 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적
-   예외 추적: 예외가 발생하면 예외 추적 서비스에 보고. 중복된 예외를 걸러내고 개발자에게 경고를 보내거나 그 해결 상태를 추적
-   애플리케이션 지표: 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출
-   감사 로깅: 사용자가 한 일을 기록

### 서비스 테스트 자동화 패턴

-   컨슈머 주도 계약 테스트(consumer-driven contract test): 클라이언트가 의도한 대로 서비스가 작동하는지 확인
-   컨슈머 쪽 계약 테스트(consumer-side contract test): 클라이언트와 서비스가 상호 통신 가능한지 확인.
-   서비스 컴포넌트 테스트(service component test): 서비스를 따로따로 테스트합니다.

### 횡단 관심사 처리 패턴

-   횡단 관심사를 처리하는 프레임워크에서 마이크로서비스 섀시(Microservice Chassis)패턴을 적용하여 서비스 구축

### 보안패턴

-   일반적으로 API 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보를 전달
-   일반적인 솔루션: JWT 같은 엑세스 토큰패턴 적용

    <br />

## 질문사항

### 1.6.2 패턴 및 패턴 언어

1. `결과 맥락: 패턴 적용 결과` 에서 단점과 이슈가 분리되어 있는 점이 궁금합니다. 패턴을 적용한 뒤에 문제점이 발생했다면 이를 단점으로 정리하는 느낌일까요? 그리고 여기서 단점의 경우에는 `미해결 강제 조항 등` 이라고 예시가 적혀 있는데 반드시 처리해야할 이슈이지만 해결되지 않은 사항들을 말할 것 같은데 해결을 하는 과정중에 문제가 있어 해결을 하지 못한 것을 의미하나요?

2. `[page53] 그림1-9`에서 컨테이너별 서비스에서 호스트별 단일 서비스로 가는 플로우가 구체적에서 일반적인 범례라고 명시되어 있는데 이것이 `세분화`에서 `일반화`로 가는 단계라고 볼 수 있을까요? 컨테이너별 서비스에서 나온 특정 패턴을 더 세부적으로 나타낸 뒤에 호스트별 단일 서비스에 문제를 해결하는 일반화된 패턴을 적용하는 것인가요??
    - 패턴 간 관계 유형 중 `한 패턴이 다른 패턴을 구체화한 패턴임을 표시` 라고 되어 있는데 위의 질문과 엮어서 물어본다면 한 패턴이 구체화된 패턴으로 표시할 수 있고 이를 일반화한 패턴으로 표시할 수 있다는 것을 의미하는 것인가요?

### 1.6.3 통신 패턴

1. 통신 패턴에서 `신뢰성` 에 대해서 궁금한 점인데, 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가? 라는 질문에서 마이크로서비스 아키텍처가 이러한 문제가 생기지 않도록 독립적으로 서비스가 이루어진다고 생각을 했었습니다. 여기에서 서비스가 불능 일 경우 다른 서비스 간의 통신에 대한 신뢰를 보장한다는 것이 어떤것을 의미하는지 정확하게 다가오지 않는 것 같습니다.

-   회로 차단기에 대한 내용은 2장에서 나올

### 관측성 패턴

1. 모놀리식의 경우 해당 인스턴스의 로그 파일을 통해서 트랙킹을 할 수 있지만, 마이크로서비스 아키텍처는 로그파일 하나로는 원인 파악이 힘들다고 하는데, `로그 수집`은 모든 서비스에 대해서 각각 하나의 서비스에 하나의 로그파일들을 생성, 로그 수집, 이것을 통합하는 로깅 서버를 구축해서 관리 하는 순서가 맞을까요?

-   A. header 안에 생성 넘기면서 계속 유지를 하기
-   A. zipkin 알아보기
-   A. pinpoint 알아보기
-   A. 분산 추적 이라는 키워드로 검색하면 더 많은 정보 얻을 수 있다!

2. 정말 이해를 못한거여서요 ㅠ`감사로깅`에서 사용자란 애플리케이션을 사용하는 유저들을 말하는 건가요? 만약 유저들이라고 하면 한 일이라면 어떤 일들을 기록하는 것일까요?

-   A. 사용자의 모든 패턴을 기록,
-   A. 한달동안 열개의 이벤트를 이용한다고 하면 생성했을 때, DB에 저장하지 않는 데이터, user id를 elastic search를 이용해 필터링 하여 유저가 회원가입부터 끝까지 어떤 로직으로 이용했는지 로깅가능
-   A. 이상 현상 탐지,
-   A. 인프라 쪽에서는 보안적인 접근권한이 없는 유저인데 접근을 시도 했을 경우
-   A. kibana

### 서비스 테스트 자동화 패턴

1. TDD나 테스트코드를 짤 때 컨슈머 주도 계약 테스트, 컨슈머 쪽 계약 테스트, 서비스 컴포넌트 테스트 이 3가지 패턴에 따라서 만들어야 되는 건가요?

-   A. 카오스 엔지니어링. 많이 나오는 키워드 한번 검색해보기
-   A. 참고사이트 : https://techblog.woowahan.com/6557/
