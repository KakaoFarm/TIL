# 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

단일 DB에 접근하는 모놀리식 애플리케이션의 트랜잭션 관리는 어렵지 않지만 다중 DB, 다중 메시지 브로커를 사용하는 모놀리식 애플리케이션, 자체 DB를 가진 여러 서비스로 구성된 마이크로 서비스 아키텍쳐는 트랜잭션 관리가 어려워 좀 더 정교한 매커니즘이 필요.

<br />

## 4.1.1 분산 트랜잭션의 필요성

-   여러 서비스의 데이터를 수정하는 메서드를 두고 서비스 간 데이터 일관성을 유지할 수 있는 수단이 필요.
    <img src="https://thebook.io/img/007035/157.jpg">

## 4.1.2 분산 트랜잭션의 문제점

-   NoSQL DB와 현대 메시지 브로커는 분산 트랜잭션을 지원하지 않음.
-   동기 IPC 형태라서 가용성이 떨어짐.
    -   에릭 브루어 CAP 정리
    -   요즘 아키텍처는 일관성보다 가용성을 더 우선시.

<br />

## 4.1.3 데이터 일관성 유지: 사가 패턴

-   사가
    -   마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘.
    -   여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의.
    -   비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션 -> 서비스 간 데이터 일관성을 사가로 유지

### 예제: 주문 생성 사가

 <img src="https://thebook.io/img/007035/159.jpg">
 - createOrder(): 여러 서비스의 로컬 트랜잭션으로 구성된 사가로 구현

#### 예제: 주문 생성 사가의 로컬 트랜잭션

-   메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장.

1. 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성.
2. 소비자 서비스: 주문 가능한 소비자인지 확인.
3. 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성.
4. 회계 서비스: 소비자 신용카드를 승인.
5. 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE로 변경.
6. 주문 서비스: 주문 상태를 APPROVED로 변경.

### 사가는 보상 트랜잭션으로 변경분을 롤백한다.

-   사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능.
-   보상 트랜잭션(compensating transaction)을 미리 작성.
-   비즈니스 규칙에 위배되어 어느 사간 단계에서 실패하면 사가는 보상 트랜잭션을 실행하여 이전 단계에서 발생한 업데이트를 언두.

#### 트랜잭션 구분

-   1~3번째 단계: 실패할 가능성이 있는 단계 다음에 있으므로 `보상 트랜잭션(compensatable transaction)`
-   4번째 단계: 절대로 실패하지 않는 단계 다음에 있으므로 `피봇 트랜잭션(pivot transaction)`
-   5~6번째 단계: 항상 성공하기 때문에 `재시도 가능 트랜잭션(retriable transaction)`

| 단계 | 서비스        | 트랜잭션                | 보상 트랜잭션  |
| :--- | :------------ | :---------------------- | -------------- |
| 1    | 주문 서비스   | createOrder()           | rejectOrder()  |
| 2    | 소비자 서비스 | verifyConsumerDetails() | -              |
| 3    | 주방 서비스   | createTicket()          | rejectTicket() |
| 4    | 회계 서비스   | authorizeCreditCard()   | -              |
| 5    | 주방 서비스   | approveTicket()         | -              |
| 6    | 주문 서비스   | approveOrder()          | -              |

<br />

## 개념

-   에릭 브루어 CAP 이론(2000년): `분산 환경에서는 일관성(Consistency), 가용성(Availablity), 네트워크 파티션 허용(Tolerance to network Partition)의 3가지 특징 중 최대 두 가지만 만족할 수 있다`
    -   `Consistency`: 모든 노드는 같은 시간에 모든 고객에게 같은 데이터를 보여줘야 한다. 쓰기 동작이 완료된 후에 발생하는 읽기 동작에서는 마지막 데이터를 반환해야 한다.
    -   `Availabilty(가용성)`: 모든 고객은 항상 읽거나 쓸 수 있어야 한다. 특정 노드에 장애가 발생하여도 서비스는 가능해야 한다.
    -   `Partition Tolerance(파티션 허용차)`:
        -   네트워크 노드로 분산되어 있어도 시스템을 동작할 수 있어야 한다.
        -   노드간에 통신에 문제가 발생하여도 정상적으로 동작해야 한다.
        -   노드는 정상인데 네트워크 등과 같은 문제로 서로간에 연결이 끊어진 상황을 말하는 것.

<br />

## 레퍼런스

[클린아키텍처 - Python](https://velog.io/@jahoy/Python%EC%9C%BC%EB%A1%9C-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B02)
