# 7.1 API 조합 패턴 응용 쿼리

## 7.1.1 findOrder() 쿼리

findOrder()는 기본키로 주문 정보를 조회하는 메서드.

### 모놀리식 애플리케이션

-   전체 데이터가 하나의 DB에 있기 때문에 알기 쉽게 `SELECT` 문으로 여러 테이블을 조인해서 주문 내역을 조회

### 마이크로서비스 아키텍처

-   데이터가 여러 서비스에 뿔뿔이 흩어져 있기 때문에 클라이언트가 주문내역을 조회 시 모든 서비스에 요청을 보내야 함.

<b>ex)</b>

-   주문 서비스: 주문 기본 정보(주문 내역, 주문 상태 등)
-   주방 서비스: 음식점 관점의 주문 상태, 픽업 준비까지 예상 소요 시간
-   배달 서비스: 주문 배달 상태, 배달 예상 정보, 현재 배달원 위치
-   회계 서비스: 주문 지불 상태

<br />

## API 조합 패턴 개요

API 조합 패턴: 여러 서비스에 있는 데이터를 API를 통해 조회하고 그 결과를 조합하여 쿼리를 구현

-   API 조합기: 프로바이더(provider) 서비스를 쿼리하여 데이터를 조회
-   프로바이더 서비스: 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

### API 조합기

-   웹 애플리케이션처럼 웹 페이지에 데이터를 렌더링하는 클라이언트
-   쿼리 작업을 API 끝점으로 표출한 API 게이트웨이
-   프런트엔드를 위한 백엔드 패턴의 변형

<br />

## 7.1.3 API를 조합 패턴으로 findOrder() 쿼리 구현

### 주문 검색 조합기

-   `GET` /orders/{orderId}
-   orderId로 네 서비스를 호출한 후 수신한 응답을 조인

### 4개의 서비스

-   주문 서비스: `GET` /orders/{orderId}
-   주방 서비스: `GET` /tickets?orderId={orderId}
-   배달 서비스: `GET` /deliveries?orderId={orderId}
-   회계 서비스: `GET` /charges?orderId={orderId}

주문 서비스는 기본키로 자신의 Order를 조회하고, 다른 서비스는 orderId를 외래키로 자신의 애그리거트를 조회

<br />

## API 조합 설계 이슈

-   어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
-   어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

### 누가 API 조합기 역할을 맡을 것인가?

-   `서비스 클라이언트를 API 조합기로 임명`

    -   동일한 LAN에서 실행중이라하면 가장 효율적으로 조회를 할 수 있지만, 클라이언트가 방화벽 외부에 있고 서비스가 위치한 네트워크가 느리다면 실용적이지 않음.

-   `애플리케이션의 외부 API가 구현된 API 게이트웨이를 API 조합기로 만들기.`

    -   모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있어 효율적

-   `API 조합기를 스탠드얼론 서비스로 구현`
    -   여러 서비스가 사용하는 쿼리 작업일 때 좋음.
    -   최합 로직이 너무 복잡해서 API 게이트웨이 일부로 만들기 곤란하거나 외부에서 접근 가능한 쿼리 작업을 구현할 경우 좋음.

### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다.

-   분산 시스템을 개발할 때 지연 시간을 최소화.
-   호출 대상 서비스들 간의 의존성이 없다면 병렬 호출이 되지만, 의존성이 있어서 순차적으로 호출이 되어야 할 경우 문제
-   순차/병렬 서비스 호출이 뒤섞인 실행 로직은 복잡해질 수 있음.

#### 관리가 용이하고 성능/확장성도 우수한 API 조합기 작성 시

-   자바의 CompletableFuture, RxJava의 옵저버블
-   위와 동등한 추상체에 기반한 리액티브 설계 기법 동원

<br />

## API 조합 패턴의 장단점

### 장점

-   마이크로서비스 아키텍처에서 아주 쉽고 단순하게 쿼리작업을 구현

### 단점

-   오버헤드 증가
-   가용성 저하 우려
-   데이터 일관성 결여

### 1. 오버헤드 증가

어려 서비스를 호출하고 여러 DB를 쿼리하기 때문에 컴퓨팅/네트워크 리소스가 더 많이 소모되고 애플리케이션 운영비용이 증가

### 2. 가용성이 저하될 우려가 있다

어떤 작업의 가용성은 더 많은 서비스가 개입할수록 감소.

#### 가용성을 높이는 전략

-   프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환.
-   API 조합기가 미완성된 데이터를 반환.
    -   한 서비스가 일시 불능 상태가 되면 조합기가 이 서비스의 데이터만 제외한 나머지 데이터를 반환.

### 3. 데이터 일관성이 결여된다.

API 조합 패턴은 여러 DB를 대상으로 여러 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반환될 수 있음

-   주문 서비스가 조회한 주문 상태는 `CANCELED` 이지만, 주방 서비스가 조회한 이 주문 티켓은 아직 취소되지 않았을 수 도 있음.

-   효율적으로 구현하기 어려운 (커대한 데이터 뭉치를 인-메모리 조인하는) 쿼리 작업은 CQRS 패턴으로 구현하는 것이 좋음.
