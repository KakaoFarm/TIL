# 7.3 CQRS 뷰 설계

## 중요한 설계 결정 사항

-   DB를 선정하고 스키마를 설계해야 한다.
-   데이터 접근 모듈을 설계할 때 멱등한/동시 업데이트 등 다양한 문제를 고려해야 한다.
-   기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로 빌드할 수 있는 수단 강구
-   뷰 클라이언트에서 복제 시차를 어떻게 처리할지 결정

<br />

## 7.3.1 뷰 DB 선택

### SQL 대 NoSQL DB

#### NoSQL DB

-   대부분 트랜잭션 기능이 제한적이고 범용적인 쿼리 능력이 없듬.
-   어떤 유스 케이스는 유연한 데이터 모델, 우수한 성능/확장성 등 SQL기반 DB보다 더 나음.
-   CQRS 뷰와 잘 맞는 편.

#### SQL DB

-   최신 RDBMS는 예전보다 성능이 뛰어남
-   대부분의 개발자들은 SQL DB가 NoSQL 보다 익숙
-   확장판으로 비관계형 기능(예: 지리 공간 데이터형 및 쿼리)을 추가
-   리포팅 엔진(reporting engine)

### 업데이트 작업 지원

-   일부 DB 자료형은 외래키 기반의 업데이트 작업을 효율적으로 지원,
-   NoSQL DB에서는 비기본키(non-primary key) 기반으로 업데이트하기가 쉽지 않음.
    -   기본키 기반의 수정/삭제만 지원되는 DynamoDB를 사용한다면, DynamoㅎDB 보조 인덱스(secondary index)를 쿼리해서 수정/삭제할 항목의 기본키를 결정해야 함.

<br />

## 7.3.2 데이터 접근 모듈 설계

-   이벤트 핸들러와 쿼리 API 모듈은 DB에 직접 접근하지 않고 데이터 접근 객체(DAO) 및 헬퍼 글래스로 구성된 데이터 접근 모듈울 사용.

### 동시성 처리

뷰가 여러 종류위 애그리거트가 발행한 이벤트를 구독할 경우, 여러 이벤트 핸들러가 동일한 레코드에 달려들어 업데이트 할 수 있음.

-   DAO가 동시 업데이트로 서로가 서로의 데이터를 덮어 쓰지 않도록 작성되어야 함.
-   DAO가 만약 레코드를 읽고 업데이트된 레코드를 쓴다면 낙관적 잠금이든, 비관적 잠금이든 둘 중 하나를 적용해야 한다.
-   DB 레코드를 먼저 읽기 않고 업데이트하는 식으로 동시 업데이트를 처리하는 DAO를 둔다.

### 멱등한 이벤트 핸들러

-   이벤트 핸들러는 같은 이벤트를 한 번 이상 넘겨받고 호출될 수 있다.
-   중복 이벤트 때문에 부정확한 결과가 나온다면 멱등한 이벤트 핸들러라고 할 수 없다.
-   이벤트 핸들러가 모든 이벤트 ID를 일일이 기록할 필요는 없음.
    -   이벤추에이트처럼 이벤트 ID가 그냥 하나씩 증가하는 구조라면 주어진 애그리거트 인스턴스에서 전달받은 max(eventId)를 각 레코드에 저장

#### 이벤트 핸들러

-   반드시 이벤트 ID를 기록하고 데이터 저장소를 원자적으로 업데이트해야 한다.

-   뷰 데이터 저장소가 SQL DB일 때: 이벤트 핸들러가 처리 완료한 이벤트를 뷰 업데이트 트랜잭션의 일부로 `PROCESSED_EVENTS 테이블`에 삽입할 수 있다.
-   NoSQL DB일 때: 트랜잭션 능력이 제한적이기 때문에 이벤트 핸들러는 자신이 업데이트 하는 데이터 저장소 `'레코드'(예: MongoDB의 문서, DynamoDB의 테이블 아이템)`에 이벤트를 저장해야 한다.

### 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다.

-   커맨드와 쿼리 모듈 API를 이용하여 클라이언트가 비일관성을 감지하게 만든다.
-   커맨드 쪽 작업이 클라이언트에 발행된 이벤트의 ID가 포함된 토큰을 반환하고, 클라이언트는 이 토큰을 쿼리 작업에 전달하면 해당 이벤트에 의해 뷰가 업데이트 되지 않았을 경우 에러 반환.

<br />

## 7.3.3 CQRS 뷰 추가 및 업데이트

### 아카이빙된 이벤트를 이용하여 CQRS 뷰 구축

-   메시지 브로커는 메시지를 무기한 보관할 수 없음.
-   따라서 AWS S3같은 곳에 아카이빙된(archived), 더 오래된 이벤트를 같이 가져와야 한다.

### CQRS 뷰를 단계적으로 구축

-   전체 이벤트를 처리하는 시간/리소스가 점점 증가하고, 언젠가 뷰는 너무 느려지고 비용이 많이 들게 됨.
-   해결방법 : `2단계 증분 알고리즘` 적용

<br />

## 개념

-   `2단계 증분 알고리즘`:
    -   1단계: 주기적으로 각 애그리거트 인스턴스의 스냅샷을 그 이전의 스냅샷과 이 스냅샷이 생성된 이후 죽 발생한 이벤트를 바탕으로 계산
    -   2단계: 이렇게 계산된 스냅샷과 구 이후 발생한 이벤트를 이용하여 뷰를 생성
