# 2.1 마이크로서비스 아키텍처란 무엇인가?

마이크로서비스 아키텍처는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일(architecture style)

<br />

## 2.1.1 소프트웨어 아키텍처의 정의와 중요성

### 소프트웨어 아키텍처의 정의

```
컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트(element)와 그들 간의 관계, 그리고 이 둘의 속성(property)으로 구성된 시스템을 추론하는 데 필요한 구조(structure)의 집합이다.
- <소프트웨어 아키텍처 문서화(Documenting software Architectures)>, 바스(Bass) 등
```

#### 분해의 중요성

-   업무와 지식을 분리
-   소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힘.

### 소프트웨어 아키텍처의 4+1 뷰 모델

<img width= '100%' src="https://thebook.io/img/007035/071.jpg">

4+1 뷰 모델은 애플리케이션 아키텍처를 명쾌하게 표현하는 수단.

-   논리 뷰(logical view): 개발자가 작성한 소프트웨어 엘리먼트. 객체 지향 언어라면 클래스, 패키지가 해당되며 결국 상속, 연관, 의존 등 클래스와 패키지의 관계
-   구현 뷰(implementation view): 빌드 시스템의 결과물. 모듈(패키징된 코드)와 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성
-   프로세스 뷰(process view): 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, IPC는 프로세스 간 관계를 나타냄.
-   배포뷰(deployment view): 프로세스가 머신에 매핑되는 방법. 엘리멘트는(물리 또는 가상) 머신 및 프로세스고, 머신 간의 관계가 네트워킹.

### 아키텍처의 중요성

1. 애플리케이션이 해야 할 일을 정의한 기능 요건
2. '~성'으로 끝나는 서비스 품질 요건

<br />

## 2.1.2 아키텍처의 스타일 개요

```
아키텍처 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다.
좀 더 구체적으로 말하면, 아키텍처 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 컴포넌트와 커넥터의 보케블러리, 그리고 이들을 조합할 수 있는 제약 조건을 결정한다.
```

### 계층화 아키텍처의 스타일

계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한.

#### 3계층 아키텍처

-   표현계층(presentation layer): 사용자 인터페이스 또는 외부 API가 구현된 계층
-   비지니스 로직 계층(business logic layer): 비지니스 로직이 구현된 계층
-   영속화계층(persistence layer): DB 상호 작용 로직이 구현된 계층

#### 3계층 아키텍처 단점

-   표현 계층이 하나뿐이다.
-   영속화 계층이 하나뿐이다.
-   비지니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다.

### 육강형 아키텍처 스타일

애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리키에션을 호출하는 아웃바운드 어댑터를 둠.

-   비지니스 로직이 어댑터에 전혀 의존하지 않는다.
-   비즈니스 로직에는 하나 이상의 포트가 있으며, 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업(operation)

인바운드 포트 : 비즈니스 로직이 표출된 API, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출
아웃바운드 포트 : 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것
인바운드 어댑터 : 외부에서 들어온 요청을 인바운드 포트를 호출해서 처리
아웃바운드 어댑터 : 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리

#### 육각형 아키텍처 스타일의 장점

-   비즈니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되었기 때문에 비즈니스 로직이 표현/데이터 로직 어디에도 의존하지 않음.

## 2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다.

-   패턴 모놀리식 아키텍처 : 애플리케이션을 실행/배포 가능한 단일 컴포넌트로 구성한다.
-   패턴 마이크로서비스 아키텍처 : 애플리케이션을 느슨하게 결합된, 독립적으로 배포 가능한 여러 서비스로 구성한다.

### 서비스란 무엇인가?

서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트.

<b>서비스 작업</b>

-   커맨드(command, 명령/CUD)
-   쿼리(query, 조회/R)

<b> 캡슐화</b>

-   서비스 API는 내부 구현 상세를 캡슐화
-   각각의 마이크로서비스는 자체 아키텍처를 갖고 있기 때문에 기술 스택을 독자적으로 구축할 수 있지만, 대부분 육각형 아키텍처 형태
-   서비스 구현 뷰는 스탠드얼론(standalone) 프로세스, 컨테이너 내부에서 실행되는 웹 애플리케이션, OSGI 번들, 서버리스 클라우드 기능 등 다양한 컴포넌트 사용

### 느슨하게 결합

-   구현 코드를 감싼 API를 통해서만 상호 작용하므로, 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드 수정
-   서비스가 직접 DB와 통신하는 일은 불가능
-   클래스 필드 같은 서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야 함.

### 공유 라이브러리의 역할

-   재사용한 기능을 라이브러리로 패키징하여 서비스 코드 중복을 줄이는 것은 좋지만, 의도치 않은 서비스 간 결합도를 유발하지 않도록 주의.
-   변경 가능성이 조금이라도 있는 기능이라면 별도의 서비스로 구현.
-   바뀔 일이 거의 없는 기능은 라이브러리에 담아 쓰기.

### 서비스 규모는 별로 중요하지 않다.

크기보다는 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계
