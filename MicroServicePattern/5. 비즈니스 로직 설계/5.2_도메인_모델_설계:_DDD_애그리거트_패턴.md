# 5.2 도메인 모델 설계: DDD 애그리거트 패턴

## Description

### 전통적인 객체 지향 설계에 기반한 도메인 모델

-   클래스와 클래스 간 관계를 모아 놓은 것.
-   클래스는 보통 패키지로 구성
-   서로 연관된 클래스가 그물망처럼 얽혀있음.
-   어떤 클래스가 비즈니스 객체의 일부인지 경계가 분명하지 않음.

<br />

## 5.2.1 불분명한 경계 문제

-   경계가 분명하지 않으면 비즈니스 객체를 업데이트할 때 문제가 생길 수 있다.
-   비즈니스 객체는 대부분 불변 값(invariant)이 있고 필히 준수해야 할 비즈니스 규칙이 존재.

-   비즈니스 객체 일부를 직접 업데이트 하면 결과적으로 비즈니스 규칙을 위반하므로 `DDD 애그리거트`로 해결

<br />

## 5.2.2 애그리거트는 경계가 분명하다.

도메인 모델을 여러 애그리거트로 구성하고 각 애그리거트는 한 단위로 취급 가능한 객체망

-   애그리거트는 도메인 모델을 개별적으로 이해하기 쉬운 덩어리로 분해
-   로드, 수정, 삭제 같은 작업 범위 분명
-   작업은 애그리거트 일부가 아닌 전체 애그리거트에 작용
-   보통 DB에서 통째로 가져오므로 복잡한 지연로딩 문제 X
-   애그리거트 삭제 시 해당 객체가 모두 사라짐.

### 애그리거트 구성

-   하나의 루트 엔터디
-   하나 이상의 기타 엔터디 + 밸류 객체

### 애그리거트는 일관된 경계

-   일부가 아니라 전체 애그리거트를 업데이트하므로 일관성 문제 해결
-   업데이트 작업은 애그리거트 루트에서 호출되므로 불변 값이 강제되고, 동시성도 애그리거트 루트를 잠금하여 처리

### 애그리거트를 식별하는 일이 관건

-   애그리거트와 그 경계, 그리고 루트 식별
-   애그리거트는 정해진 규칙을 반드시 준수.

<br />

## 5.2.3 애그리거트 규칙

### 규칙 #1: 애그리거트 루트만 참조하라

-   외부 클래스는 반드시 애그리거트의 루트 엔터티만 참조할 수 있게 제한
-   클라이언트는 애그리거트 루트 메서드만 호출해서 애그리거트를 업데이트

### 규칙 #2: 애그리거트 간 참조는 반드시 기본키를 사용하라

-   애그리거트는 객체 레퍼런스 대신 신원(예: 기본키)으로 서로를 참조.
-   느슨하게 결합되고 애그리거트 간 경계가 분명해지기 때문에 실수로 다른 애그리거트를 업데이트할 일은 일어나지 않음.
-   애그리거트가 다른 서비스의 일부인 경우에도 여러 서비스에 걸친 객체 레퍼런스 문제가 없음.
-   애그리거트는 그 자체가 저장 단위 이므로 저장 로직이 간단해짐.

### 규칙 #3: 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정해라

-   하나의 트랜잭션은 오직 하나의 애그리거트만 생성/수정
-   여러 애거리거트를 생성/수정하는 작업이 필요할 시 사가로 해결
    -   사가를 통해 각 단계마다 하나의 애그리거트를 생성/수정
-   서비스 하나에서 여러 애그리거트에 걸쳐 일관성을 유지하는 또 다른 방법은 여러 애그리거트를 한 트랜잭션으로 업데이트.

<br />

## 5.2.4 애그리거트 입도

-   각 애그리거트는 작으면 작을수록 좋다.
-   각 애그리거트의 업데이트는 직렬화 되므로 잘게 나뉘어져 있으면 그만큼 애플리케이션이 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아짐.
-   애그리거트를 크게 잡음으로써 원자적으로 처리할 수 있도록 설계할 수 있지만, 확장성이 떨어지고, 분해에 문제가 생기면서 서비스가 비대해짐.

<br />

## 5.2.5 비즈니스 로직 설계: 애그리거트

대부분 애그리거트로 구성되며 나머지는 도메인 서비스와 사가에 위치.

-   사가: 로컬 트랜잭션을 오케스트레이션하여 데이터 일관성을 맞춤.
-   인바운드 어댑터: 비즈니스 로직의 진입점인 서비스 호출
-   서비스: 리포지터리로 DB에서 애그리거트 조회, DB에 애그리거트 저장.
-   리포지터리: 각각 DB에 접근하는 아웃바운드 어댑터 구현

<br />

## 개념

-   `낙관적 락(opimistic lock)`: DB 충돌 상황을 개선할 수 있는 방법 중 2번째인 수정할 때 내가 먼저 이 값을 수정했다고 명시하여 다른 사람이 동일한 조건으로 값을 수정할 수 없게 하는 것.
    -   DB에서 제공해주는 특징을 이용하는 것이 아닌 Application Level에서 잡아주는 Lock
-   `비관적 락(pessimistic lock)`: Reeatable Read 또는 Serializable 정도의 격리성 수준에서 가능. 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작하는 방법

<br />

## Reference

-   [[database] 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)](https://sabarada.tistory.com/175)

<br />

## 질문

1. `애그리거트는 보통 DB에서 통째로 가져오기 때문에 복잡한 지연 로딩 문제를 신경 쓸 필요가 없습니다.` 에서 DB에서 통째로 가져올 때 생기는 문제점이 없나요?
